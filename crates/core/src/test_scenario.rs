use crate::agent_controller::AgentStore;
use crate::buckets::Bucket;
use crate::db::{DbOps, NamedTx};
use crate::error::{ContenderError, RpcErrorKind, RuntimeParamErrorKind};
use crate::generator::named_txs::ExecutionRequest;
use crate::generator::seeder::SeedValue;
use crate::generator::templater::Templater;
use crate::generator::types::AnyProvider;
use crate::generator::util::complete_tx_request;
use crate::generator::NamedTxRequest;
use crate::generator::{seeder::Seeder, types::PlanType, Generator, PlanConfig};
use crate::provider::{LoggingLayer, RPC_REQUEST_LATENCY_ID};
use crate::spammer::tx_actor::TxActorHandle;
use crate::spammer::{ExecutionPayload, RuntimeTxInfo, SpamCallback, SpamTrigger};
use crate::util::{get_blob_fee_maybe, get_block_time, ExtraTxParams};
use crate::Result;
use alloy::consensus::constants::{ETH_TO_WEI, GWEI_TO_WEI};
use alloy::consensus::{Transaction, TxType};
use alloy::eips::eip2718::Encodable2718;
use alloy::hex::ToHexExt;
use alloy::network::{
    AnyNetwork, AnyTxEnvelope, EthereumWallet, NetworkWallet, TransactionBuilder,
};
use alloy::node_bindings::Anvil;
use alloy::primitives::{keccak256, Address, Bytes, FixedBytes, U256};
use alloy::providers::{DynProvider, PendingTransactionConfig, Provider, ProviderBuilder};
use alloy::rpc::client::ClientBuilder;
use alloy::rpc::types::TransactionRequest;
use alloy::serde::WithOtherFields;
use alloy::signers::local::{LocalSigner, PrivateKeySigner};
pub use alloy::transports::http::reqwest::Url;
use contender_bundle_provider::bundle::BundleType;
use contender_bundle_provider::bundle_provider::new_basic_bundle;
use contender_bundle_provider::revert_bundle::RevertProtectBundleRequest;
use contender_bundle_provider::BundleClient;
use contender_engine_provider::AdvanceChain;
use futures::{Stream, StreamExt};
use std::collections::{BTreeMap, HashMap};
use std::ops::Deref;
use std::pin::Pin;
use std::str::FromStr;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::OnceCell;
use tokio_util::sync::CancellationToken;
use tracing::{debug, error, info, trace, warn};

#[derive(Clone)]
pub struct PrometheusCollector {
    prom: &'static OnceCell<prometheus::Registry>,
    hist: &'static OnceCell<prometheus::HistogramVec>,
}

impl Default for PrometheusCollector {
    fn default() -> Self {
        static PROM: OnceCell<prometheus::Registry> = OnceCell::const_new();
        static HIST: OnceCell<prometheus::HistogramVec> = OnceCell::const_new();
        Self {
            prom: &PROM,
            hist: &HIST,
        }
    }
}

impl
    From<(
        &'static OnceCell<prometheus::Registry>,
        &'static OnceCell<prometheus::HistogramVec>,
    )> for PrometheusCollector
{
    fn from(
        (prom, hist): (
            &'static OnceCell<prometheus::Registry>,
            &'static OnceCell<prometheus::HistogramVec>,
        ),
    ) -> Self {
        Self { prom, hist }
    }
}

/// A test scenario can be used to run a test with a specific configuration, database, and RPC provider.
#[derive(Clone)]
pub struct TestScenario<D, S, P>
where
    D: DbOps + Send + Sync + 'static,
    S: Seeder,
    P: PlanConfig<String> + Templater<String> + Send + Sync,
{
    pub config: P,
    pub db: Arc<D>,
    pub rpc_url: Url,
    pub builder_rpc_url: Option<Url>,
    pub auth_provider: Option<Arc<dyn AdvanceChain + Send + Sync + 'static>>,
    pub bundle_client: Option<Arc<BundleClient>>,
    pub rpc_client: Arc<AnyProvider>,
    pub rand_seed: S,
    /// Wallets explicitly given by the user
    pub wallet_map: HashMap<Address, EthereumWallet>,
    /// Wallets generated by the system
    pub agent_store: AgentStore,
    pub nonces: HashMap<Address, u64>,
    pub chain_id: u64,
    pub gas_limits: HashMap<FixedBytes<32>, u64>,
    pub msg_handles: HashMap<String, Arc<TxActorHandle>>,
    pub tx_type: TxType,
    pub bundle_type: BundleType,
    pub pending_tx_timeout_secs: u64,
    pub ctx: ExecutionContext,
    prometheus: PrometheusCollector,
    setcode_signer: PrivateKeySigner,
}

pub struct TestScenarioParams {
    pub rpc_url: Url,
    pub builder_rpc_url: Option<Url>,
    pub signers: Vec<PrivateKeySigner>,
    pub agent_store: AgentStore,
    pub tx_type: TxType,
    pub pending_tx_timeout_secs: u64,
    pub bundle_type: BundleType,
    pub extra_msg_handles: Option<HashMap<String, Arc<TxActorHandle>>>,
}

#[derive(Clone, Debug)]
pub struct ExecutionContext {
    /// Adds this amount of wei per gas to the gas price given to each transaction. May be negative to subtract gas.
    /// This is not the same as the `gas_price_percent_add`, which is a percentage of the gas price provided by the user.
    gas_price_adder: i128,
    /// The amount of time between blocks on the target chain.
    pub block_time_secs: u64,
    /// Tells us when to terminate async tasks.
    pub cancel_token: CancellationToken,
    /// Chain ID for target chain.
    pub chain_id: u64,
}

impl ExecutionContext {
    pub fn add_to_gas_price(&mut self, amount: i128) {
        self.gas_price_adder += amount;
    }
}

impl<D, S, P> TestScenario<D, S, P>
where
    D: DbOps + Send + Sync + 'static,
    S: Seeder + Send + Sync + Clone,
    P: PlanConfig<String> + Templater<String> + Send + Sync + Clone,
{
    pub async fn new(
        config: P,
        db: Arc<D>,
        rand_seed: S,
        params: TestScenarioParams,
        auth_provider: Option<Arc<dyn AdvanceChain + Send + Sync + 'static>>,
        prometheus: PrometheusCollector,
    ) -> Result<Self> {
        let TestScenarioParams {
            rpc_url,
            builder_rpc_url,
            signers,
            agent_store,
            tx_type,
            pending_tx_timeout_secs,
            bundle_type,
            extra_msg_handles,
        } = params;

        let setcode_signer_key = FixedBytes::from_slice(
            &rand_seed
                .seed_values(9001, None, None)
                .last()
                .expect("failed to generate seed value")
                .as_u256()
                .to_be_bytes_vec(),
        );
        let setcode_signer =
            PrivateKeySigner::from_bytes(&setcode_signer_key.into()).map_err(|e| {
                ContenderError::with_err(e, "failed to parse private key for setCode signer")
            })?;

        // use custom logging layer to log sendRawTransaction request IDs
        let client = ClientBuilder::default()
            .layer(LoggingLayer::new(prometheus.prom, prometheus.hist).await)
            .http(rpc_url.to_owned());
        let rpc_client = Arc::new(DynProvider::new(
            ProviderBuilder::new()
                .network::<AnyNetwork>()
                .connect_client(client),
        ));

        let mut wallet_map = HashMap::new();
        let wallets = signers.iter().map(|s| {
            let w = EthereumWallet::new(s.clone());
            (s.address(), w)
        });
        for (addr, wallet) in wallets {
            wallet_map.insert(addr, wallet);
        }
        for (name, agent) in agent_store.all_agents() {
            debug!("adding '{name}' signers to wallet map");
            for signer in agent.signers.iter() {
                wallet_map.insert(signer.address(), EthereumWallet::new(signer.clone()));
            }
        }

        let mut nonces = HashMap::new();
        sync_nonces(
            &wallet_map,
            &mut nonces,
            &rpc_client,
            setcode_signer.address(),
        )
        .await?;

        let gas_limits = HashMap::new();

        let bundle_client = if let Some(builder_url) = &builder_rpc_url {
            let client = ClientBuilder::default()
                .layer(LoggingLayer::new(prometheus.prom, prometheus.hist).await)
                .http(builder_url.to_owned());
            Some(Arc::new(BundleClient::from_client(client)))
        } else {
            None
        };

        let chain_id = rpc_client
            .get_chain_id()
            .await
            .map_err(|e| ContenderError::with_err(e, "rpc client failed to get chain id"))?;
        let chain_id_builder = if let Some(builder_client) = &bundle_client {
            builder_client
                .get_chain_id()
                .await
                .map_err(|e| ContenderError::with_err(e, "bundle client failed to get chain id"))?
        } else {
            chain_id
        };
        if chain_id != chain_id_builder {
            error!(
                "chain id mismatch: primary chain id: {chain_id}, builder chain id: {chain_id_builder}"
            );
            return Err(ContenderError::SetupError(
                "chain id must be consistent across rpc and builder",
                None,
            ));
        }

        let cancel_token = CancellationToken::new();

        // default msg_handle to handle txs sent on rpc_url
        let msg_handle = Arc::new(TxActorHandle::new(120, db.clone(), rpc_client.clone()));
        let mut msg_handles = HashMap::new();
        msg_handles.insert("default".to_owned(), msg_handle);
        msg_handles.extend(extra_msg_handles.unwrap_or_default());
        let block_time_secs = get_block_time(rpc_client.as_ref()).await?;

        Ok(Self {
            config,
            db: db.clone(),
            rpc_url: rpc_url.to_owned(),
            rpc_client,
            bundle_client,
            builder_rpc_url,
            rand_seed,
            wallet_map,
            agent_store,
            chain_id,
            nonces,
            gas_limits,
            msg_handles,
            tx_type,
            bundle_type,
            pending_tx_timeout_secs,
            ctx: ExecutionContext {
                gas_price_adder: 0,
                block_time_secs,
                cancel_token,
                chain_id,
            },
            auth_provider,
            prometheus,
            setcode_signer,
        })
    }

    pub async fn sync_nonces(&mut self) -> Result<()> {
        sync_nonces(
            &self.wallet_map,
            &mut self.nonces,
            &self.rpc_client,
            self.setcode_signer.address(),
        )
        .await
    }

    pub async fn estimate_setup_cost(&self) -> Result<U256> {
        info!(
            "
================================================================================
================= running simulation to estimate setup cost ====================
================================================================================
"
        );
        // start anvil with dev accounts holding 1M eth
        let anvil = Anvil::new()
            .args(["--balance", "1000000"])
            .try_spawn()
            .map_err(|e| {
                if e.to_string().to_lowercase().contains("no such file") {
                    ContenderError::SetupError("failed to spawn anvil. You may need to install foundry (https://book.getfoundry.sh/getting-started/installation).", None)
                } else {
                    ContenderError::with_err(e, "failed to spawn anvil.")
                }
            })?;
        let admin_signer = LocalSigner::from_str(
            "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
        )
        .expect("invalid signer");
        // separate prometheus registry for simulations; anvil doesn't count!
        static PROM: OnceCell<prometheus::Registry> = OnceCell::const_new();
        static HIST: OnceCell<prometheus::HistogramVec> = OnceCell::const_new();
        let mut scenario = Self::new(
            self.config.to_owned(),
            self.db.clone(),
            self.rand_seed.to_owned(),
            TestScenarioParams {
                rpc_url: anvil.endpoint_url(),
                builder_rpc_url: None,
                signers: vec![admin_signer.to_owned()],
                agent_store: self.agent_store.clone(),
                tx_type: self.tx_type,
                bundle_type: self.bundle_type,
                pending_tx_timeout_secs: self.pending_tx_timeout_secs,
                extra_msg_handles: None,
            },
            None,
            (&PROM, &HIST).into(),
        )
        .await?;

        let addresses = scenario
            .agent_store
            .all_signer_addresses()
            .into_iter()
            .collect::<Vec<Address>>();

        let fund_amount = if addresses.len() >= 999 {
            U256::from(999999 * ETH_TO_WEI / addresses.len() as u128)
        } else {
            U256::from(1000 * ETH_TO_WEI)
        };
        let start_balances: HashMap<Address, U256> =
            HashMap::from_iter(addresses.iter().map(|addr| (*addr, fund_amount)));

        for (_name, agent) in scenario.agent_store.all_agents() {
            agent
                .fund_signers(&admin_signer, fund_amount, scenario.rpc_client.clone())
                .await
                .map_err(|e| ContenderError::with_err(e.deref(), "failed to fund signers"))?;
        }

        debug!("deploying sim contracts...");
        scenario.deploy_contracts().await?;
        debug!("sim contracts deployed, running setup...");
        scenario.run_setup().await?;

        let mut total_cost = U256::ZERO;
        for (addr, start_balance) in &start_balances {
            let new_balance = scenario
                .rpc_client
                .get_balance(*addr)
                .await
                .map_err(|e| ContenderError::with_err(e, "failed to get balance"))?;
            if new_balance >= *start_balance {
                continue;
            }
            let cost = start_balance - new_balance;
            total_cost += cost;
        }

        info!(
            "
================================================================================
============================= simulation complete ==============================
================================================================================
"
        );

        Ok(total_cost)
    }

    /// Funds all signers in the agent with the given amount.
    /// Does not check if the agents are already funded.
    #[deprecated(since = "0.2.2", note = "please use `agent.fund_signers` instead")]
    pub async fn fund_agent_signers(
        &mut self,
        agent_name: impl AsRef<str>,
        funder: &EthereumWallet,
        amount: U256,
    ) -> Result<Vec<PendingTransactionConfig>> {
        let addresses = self
            .agent_store
            .get_agent(&agent_name)
            .ok_or(ContenderError::SetupError(
                "agent not found",
                Some(agent_name.as_ref().to_owned()),
            ))?
            .all_addresses();
        let gas_price = self
            .rpc_client
            .get_gas_price()
            .await
            .map_err(|e| ContenderError::with_err(e, "failed to get gas price"))?;
        let blob_gas_price = get_blob_fee_maybe(&self.rpc_client).await;

        let mut pending_txs = vec![];
        for addr in addresses {
            let tx_req = TransactionRequest::default()
                .with_from(funder.default_signer().address())
                .with_to(addr)
                .with_value(amount);
            let (tx_req, _) = self
                .prepare_tx_request(&tx_req, gas_price + GWEI_TO_WEI as u128, blob_gas_price)
                .await?;
            let signed_tx = tx_req
                .build(funder)
                .await
                .map_err(|e| ContenderError::with_err(e, "failed to build funding tx"))?;
            let pending = self
                .rpc_client
                .send_tx_envelope(AnyTxEnvelope::Ethereum(signed_tx))
                .await
                .map_err(|e| ContenderError::with_err(e, "failed to send funding tx"))?;
            debug!(
                "funded account {}, tx: {}",
                addr.encode_hex(),
                pending.tx_hash()
            );
            pending_txs.push(pending.inner().to_owned());
        }

        Ok(pending_txs)
    }

    pub async fn deploy_contracts(&mut self) -> Result<()> {
        let pub_provider = &self.rpc_client;
        let gas_price = pub_provider
            .get_gas_price()
            .await
            .map_err(|e| ContenderError::with_err(e, "failed to get gas price"))?;
        let blob_gas_price = get_blob_fee_maybe(&self.rpc_client).await;
        let chain_id = pub_provider
            .get_chain_id()
            .await
            .map_err(|e| ContenderError::with_err(e, "failed to get chain id"))?;

        // we do everything in the callback so no need to actually capture the returned txs
        // we have to do this to populate the database with new named transaction after each deployment
        self.load_txs(PlanType::Create(|tx_req| {
            let from = tx_req.tx.from.to_owned().ok_or(ContenderError::SetupError(
                "failed to get 'from' address",
                None,
            ))?;
            info!(
                "deploying contract: {:?}",
                tx_req.name.as_ref().unwrap_or(&"".to_string())
            );
            let rpc_url = self.rpc_url.to_owned();
            let tx_type = self.tx_type;
            let wallet = self
                .wallet_map
                .get(&from)
                .unwrap_or_else(|| panic!("couldn't find wallet for 'from' address {from}"))
                .to_owned();
            let db = self.db.clone();

            let handle = tokio::task::spawn(async move {
                Self::deploy_contract(
                    &db,
                    &tx_req,
                    (gas_price, blob_gas_price, chain_id).into(),
                    tx_type,
                    &rpc_url,
                    &wallet,
                )
                .await
            });

            Ok(Some(handle))
        }))
        .await?;

        self.sync_nonces().await?;

        Ok(())
    }

    async fn deploy_contract(
        db: &D,
        tx_req: &NamedTxRequest,
        extra_tx_params: ExtraTxParams,
        // gas_price: u128,
        // blob_gas_price: u128,
        // chain_id: u64,
        tx_type: TxType,
        rpc_url: &Url,
        wallet: &EthereumWallet,
    ) -> Result<()> {
        let wallet_client = ProviderBuilder::new()
            .wallet(wallet)
            .network::<AnyNetwork>()
            .connect_http(rpc_url.to_owned());

        let ExtraTxParams {
            gas_price,
            blob_gas_price,
            chain_id,
        } = extra_tx_params;

        // estimate gas limit
        let gas_limit = wallet_client
            .estimate_gas(WithOtherFields::new(tx_req.tx.to_owned()))
            .await
            .map_err(|e| {
                ContenderError::with_err(e, "failed to estimate gas for contract deployment")
            })?;

        // inject missing fields into tx_req.tx
        let mut tx = tx_req.tx.to_owned();
        complete_tx_request(
            &mut tx,
            tx_type,
            gas_price,
            gas_price / 10,
            gas_limit,
            chain_id,
            blob_gas_price,
        );
        let from = <EthereumWallet as NetworkWallet<AnyNetwork>>::default_signer_address(wallet);

        let res = wallet_client
            .send_transaction(WithOtherFields::new(tx))
            .await
            .map_err(|err| {
                let e = err.to_string().to_lowercase();
                if e.contains("already known") {
                    ContenderError::RpcError(crate::error::RpcErrorKind::TxAlreadyKnown, err)
                } else if e.contains("insufficient funds") {
                    ContenderError::RpcError(RpcErrorKind::InsufficientFunds(from), err)
                } else if e.contains("replacement transaction underpriced") {
                    ContenderError::RpcError(RpcErrorKind::ReplacementTransactionUnderpriced, err)
                } else {
                    RpcErrorKind::GenericSendTxError.to_error(err)
                }
            })?;
        // watch pending transaction
        let receipt = res.get_receipt().await.expect("failed to get receipt");
        debug!(
            "contract address: {}",
            receipt.contract_address.unwrap_or_default()
        );
        if let Some(name) = &tx_req.name {
            db.insert_named_txs(
                &[NamedTx::new(
                    name.to_owned(),
                    receipt.transaction_hash,
                    receipt.contract_address,
                )],
                rpc_url.as_str(),
            )?;
        } else {
            warn!("No name provided for named transaction. This may cause issues with tracking the entry in the database.");
        }
        Ok(())
    }

    pub async fn run_setup(&mut self) -> Result<()> {
        let chain_id = self.chain_id;
        self.load_txs(PlanType::Setup(|tx_req| {
            /* callback */
            info!("{}", self.format_setup_log(&tx_req));

            // copy data/refs from self before spawning the task
            let from = tx_req.tx.from.as_ref().ok_or(ContenderError::SetupError(
                "failed to get 'from' address",
                None,
            ))?;
            let wallet = self
                .wallet_map
                .get(from)
                .ok_or(ContenderError::SetupError(
                    "couldn't find private key for address",
                    from.encode_hex().into(),
                ))?
                .to_owned();
            let db = self.db.clone();
            let rpc_url = self.rpc_url.clone();
            let tx_type = self.tx_type;

            let handle = tokio::task::spawn(async move {
                let wallet = ProviderBuilder::new()
                    .wallet(wallet)
                    .network::<AnyNetwork>()
                    .connect_http(rpc_url.to_owned());

                let tx_label = tx_req
                    .name
                    .as_deref()
                    .or(tx_req.kind.as_deref())
                    .unwrap_or("")
                    .to_string();
                let gas_price = wallet.get_gas_price().await.map_err(|e| {
                    warn!("failed to get gas price for setup step '{tx_label}'");
                    ContenderError::with_err(e, "failed to get gas price")
                })?;
                let blob_gas_price = get_blob_fee_maybe(&DynProvider::new(wallet.to_owned())).await;
                let gas_limit = if let Some(gas) = tx_req.tx.gas {
                    gas
                } else {
                    wallet
                        .estimate_gas(tx_req.tx.to_owned().into())
                        .await
                        .map_err(|e| {
                            warn!("failed to estimate gas for setup step '{tx_label}'");
                            ContenderError::with_err(e, "failed to estimate gas")
                        })?
                };
                let mut tx = tx_req.tx;
                complete_tx_request(
                    &mut tx,
                    tx_type,
                    gas_price,
                    gas_price / 10,
                    gas_limit,
                    chain_id,
                    blob_gas_price,
                );

                // wallet will assign nonce before sending
                let res = wallet.send_transaction(tx.into()).await.map_err(|e| {
                    warn!("failed to send setup tx '{tx_label}'");
                    ContenderError::with_err(e, "setup tx failed")
                })?;

                // get receipt using provider (not wallet) to allow any receipt type (support non-eth chains)
                let receipt = res
                    .get_receipt()
                    .await
                    .map_err(|e| ContenderError::with_err(e, "failed to get receipt"))?;

                if let Some(name) = tx_req.name {
                    db.insert_named_txs(
                        &[NamedTx::new(
                            name,
                            receipt.transaction_hash,
                            receipt.contract_address,
                        )],
                        rpc_url.as_str(),
                    )?;
                }

                Ok(())
            });
            Ok(Some(handle))
        }))
        .await?;

        self.sync_nonces().await?;

        Ok(())
    }

    pub async fn prepare_tx_request(
        &mut self,
        tx_req: &TransactionRequest,
        gas_price: u128,
        blob_gas_price: u128,
    ) -> Result<(TransactionRequest, EthereumWallet)> {
        let from = tx_req.from.ok_or(ContenderError::SetupError(
            "missing 'from' address in tx request",
            None,
        ))?;
        let nonce = self
            .nonces
            .get(&from)
            .ok_or(ContenderError::SetupError(
                "missing nonce for 'from' address",
                Some(from.to_string()),
            ))?
            .to_owned();
        let alice_addr = self.setcode_signer.address();
        let alice_nonce = self
            .nonces
            .get(&alice_addr)
            .ok_or(ContenderError::SetupError(
                "missing nonce for 'from' address",
                Some(from.to_string()),
            ))?
            .to_owned();

        self.nonces.insert(from.to_owned(), nonce + 1);
        if tx_req.authorization_list.is_some() {
            self.nonces.insert(alice_addr, alice_nonce + 1);
        }

        let key = keccak256(tx_req.input.input.to_owned().unwrap_or_default());

        if let std::collections::hash_map::Entry::Vacant(_) = self.gas_limits.entry(key) {
            let gas_limit = if let Some(gas) = tx_req.gas {
                gas
            } else {
                self.rpc_client
                    .estimate_gas(WithOtherFields::new(tx_req.to_owned()))
                    .await
                    .map_err(|e| {
                        if e.as_error_resp().is_some() {
                            tracing::error!("failed tx: {tx_req:?}");
                        }
                        ContenderError::with_err(e, "failed to estimate gas for tx")
                    })?
            };
            self.gas_limits.insert(key, gas_limit);
        }
        let gas_limit = self
            .gas_limits
            .get(&key)
            .ok_or(ContenderError::SetupError(
                "failed to lookup gas limit",
                None,
            ))?
            .to_owned();
        let signer = self
            .wallet_map
            .get(&from)
            .ok_or(ContenderError::SetupError(
                "failed to get signer from scenario wallet_map",
                None,
            ))?
            .to_owned();

        let mut full_tx = tx_req.to_owned().with_nonce(nonce);
        complete_tx_request(
            &mut full_tx,
            self.tx_type,
            gas_price,
            gas_price / 10,
            gas_limit,
            self.chain_id,
            blob_gas_price,
        );

        Ok((full_tx, signer))
    }

    pub async fn prepare_spam(
        &mut self,
        tx_requests: &[ExecutionRequest],
    ) -> Result<Vec<ExecutionPayload>> {
        let gas_price = self
            .rpc_client
            .get_gas_price()
            .await
            .map_err(|e| ContenderError::with_err(e, "failed to get gas price"))?;
        let blob_gas_price = get_blob_fee_maybe(&self.rpc_client).await;
        let adjusted_gas_price = |price: u128| {
            if self.ctx.gas_price_adder < 0 {
                price - self.ctx.gas_price_adder.unsigned_abs()
            } else {
                price + self.ctx.gas_price_adder as u128
            }
        };
        let gas_price = adjusted_gas_price(gas_price);
        let blob_gas_price = adjusted_gas_price(blob_gas_price);

        let mut payloads = vec![];
        info!("preparing {} spam payloads", tx_requests.len());
        for tx in tx_requests {
            let payload = match tx {
                ExecutionRequest::Bundle(reqs) => {
                    // prepare each tx in the bundle (increment nonce, set gas price, etc)
                    let mut bundle_txs = vec![];
                    if self.bundle_client.is_none() {
                        return Err(RuntimeParamErrorKind::BuilderUrlRequired.into());
                    }

                    for req in reqs {
                        let (tx_req, signer) = self
                            .prepare_tx_request(&req.tx, gas_price, blob_gas_price)
                            .await
                            .map_err(|e| ContenderError::with_err(e, "failed to prepare tx"))?;

                        trace!("bundle tx: {tx_req:?}");
                        // sign tx
                        let tx_envelope = tx_req.build(&signer).await.map_err(|e| {
                            ContenderError::with_err(e, "bad request: failed to build tx")
                        })?;

                        bundle_txs.push(tx_envelope);
                    }
                    ExecutionPayload::SignedTxBundle(bundle_txs, reqs.to_owned())
                }
                ExecutionRequest::Tx(req) => {
                    let (tx_req, signer) = self
                        .prepare_tx_request(&req.tx, gas_price, blob_gas_price)
                        .await
                        .map_err(|e| ContenderError::with_err(e, "failed to prepare tx"))?;
                    let mut new_req = req.to_owned();
                    new_req.tx = tx_req.to_owned();

                    // sign tx
                    let tx_envelope = tx_req.build(&signer).await.map_err(|e| {
                        ContenderError::with_err(e, "bad request: failed to build tx")
                    })?;

                    // log tx details
                    let priority_fee = new_req
                        .tx
                        .max_priority_fee_per_gas
                        .map(|f| format!(" priority_fee: {f},"))
                        .unwrap_or_default();
                    debug!(
                        "prepared tx: {}, from: {}, to: {:?}, input: {}, value={}, gas_limit: {}, gas_price: {},{priority_fee} nonce={}",
                        tx_envelope.tx_hash(),
                        new_req.tx.from.map(|s| s.encode_hex()).unwrap_or_default(),
                        tx_envelope.to(),
                        new_req.tx
                            .input
                            .input
                            .as_ref()
                            .map(|s| s.encode_hex())
                            .unwrap_or_default(),
                        new_req.tx
                            .value
                            .map(|s| s.to_string())
                            .unwrap_or("0".to_owned()),
                        new_req.tx
                            .gas
                            .map(|g| g.to_string())
                            .unwrap_or("N/A".to_owned()),
                        new_req.tx.gas_price.unwrap_or(new_req.tx.max_fee_per_gas.unwrap_or(0)),
                        new_req.tx.nonce.map(|n| n.to_string()).unwrap_or("N/A".to_owned())
                    );

                    ExecutionPayload::SignedTx(Box::new(tx_envelope), new_req)
                }
            };
            payloads.push(payload);
        }
        info!("prepared {} payloads", payloads.len());
        Ok(payloads)
    }

    /// Send one batch of spam txs evenly over one second.
    async fn execute_spam<F: SpamCallback + 'static>(
        &mut self,
        trigger: SpamTrigger,
        payloads: Vec<ExecutionPayload>,
        callback_handler: Arc<F>,
        context_handler: SpamContextHandler,
    ) -> Result<(
        Vec<tokio::task::JoinHandle<()>>,
        tokio::sync::mpsc::Receiver<ContenderError>,
    )> {
        // sort payloads by nonce
        let mut payloads = payloads;
        payloads.sort_by(|a, b| {
            let a_nonce = match a {
                ExecutionPayload::SignedTx(_, req) => req.tx.nonce,
                ExecutionPayload::SignedTxBundle(_, reqs) => reqs[0].tx.nonce,
            };
            let b_nonce = match b {
                ExecutionPayload::SignedTx(_, req) => req.tx.nonce,
                ExecutionPayload::SignedTxBundle(_, reqs) => reqs[0].tx.nonce,
            };
            a_nonce.cmp(&b_nonce)
        });

        let num_payloads = payloads.len();

        let mut tasks: Vec<tokio::task::JoinHandle<()>> = vec![];

        // spawn at regular interval
        let micros_per_task = 1_000_000 / num_payloads.max(1) as u64;

        // takes gas to add to the gas price for the next batch (if needed)
        let gas_sender = Arc::new(context_handler.add_gas);
        // counts number of txs that were sent successfully
        let success_sender = Arc::new(context_handler.success_send_tx);
        let bundle_type = self.bundle_type;
        let (error_sender, error_receiver) = tokio::sync::mpsc::channel::<ContenderError>(1);
        let error_sender = Arc::new(error_sender);

        for payload in payloads {
            let rpc_client = self.rpc_client.clone();
            let bundle_client = self.bundle_client.clone();
            let tx_handlers = self.msg_handles.clone();
            let callback_handler = callback_handler.clone();
            let gas_sender = gas_sender.clone();
            let success_sender = success_sender.clone();
            let cancel_token = self.ctx.cancel_token.clone();
            let error_sender = error_sender.clone();

            // wait to space transactions out evenly across a second
            std::thread::sleep(Duration::from_micros(micros_per_task));
            tasks.push(tokio::task::spawn(async move {
                let extra = RuntimeTxInfo::default();
                let handles = match payload {
                    ExecutionPayload::SignedTx(signed_tx, req) => {
                        let tx_hash = signed_tx.tx_hash().to_owned();
                        let res = rpc_client
                            .send_tx_envelope(AnyTxEnvelope::Ethereum(*signed_tx))
                            .await;

                        match res {
                            Ok(res) => {
                                let maybe_handle = callback_handler.on_tx_sent(
                                    res.into_inner(),
                                    &req,
                                    extra,
                                    Some(tx_handlers),
                                );

                                tokio::select! {
                                    _ = cancel_token.cancelled() => {
                                        return;
                                    }
                                    _ = success_sender
                                    .send(()) => {
                                        // wait for the task to finish
                                    }
                                };

                                vec![maybe_handle]
                            }
                            Err(e) => {
                                if let Some(err) = e.as_error_resp() {
                                    if err
                                        .message
                                        .to_lowercase()
                                        .contains("replacement transaction underpriced")
                                    {
                                        // send the current gas price / 10 to increase it by 10% for the next batch
                                        gas_sender
                                            .send(
                                                req.tx.max_fee_per_gas.unwrap_or(
                                                    req.tx.gas_price.unwrap_or(1_000_000_000),
                                                ) / 10,
                                            )
                                            .await
                                            .expect("failed to send gas update signal");
                                    }

                                    // include errored txs in the cache; user may want to retry them
                                    // if they are due to nonce issues, this will fail, but if they do land somehow,
                                    // they will be awaited in the post-spam loop
                                    warn!("error from tx {tx_hash}: {err:?}");
                                    let extra = extra.with_error(err.to_string());
                                    vec![callback_handler.on_tx_sent(
                                        PendingTransactionConfig::new(tx_hash),
                                        &req,
                                        extra,
                                        Some(tx_handlers),
                                    )]
                                } else {
                                    // ignore errors that can't be decoded
                                    warn!("ignoring tx response, could not decode error: {e:?}");
                                    vec![]
                                }
                            }
                        }
                    }
                    ExecutionPayload::SignedTxBundle(signed_txs, reqs) => {
                        let mut bundle_txs = vec![];
                        for tx in &signed_txs {
                            let mut raw_tx = vec![];
                            tx.encode_2718(&mut raw_tx);
                            bundle_txs.push(Bytes::from(raw_tx));
                        }
                        let block_num = match trigger {
                            SpamTrigger::BlockNumber(n) => n,
                            SpamTrigger::BlockHash(h) => {
                                let block = rpc_client
                                    .get_block_by_hash(h)
                                    .await
                                    .expect("failed to get block by hash")
                                    .expect("block not found");
                                block.header.number
                            }
                            _ => rpc_client
                                .get_block_number()
                                .await
                                .expect("failed to get block number"),
                        };

                        let rpc_bundle = match bundle_type {
                            BundleType::L1 => new_basic_bundle(bundle_txs, block_num + 1),
                            BundleType::RevertProtected => RevertProtectBundleRequest::new()
                                .with_txs(bundle_txs)
                                .prepare(),
                        };
                        let success_sender = success_sender.clone();
                        let bundle_client = bundle_client.expect("test_scenario must be initialized with a bundle client to send bundles");
                        info!("sending bundle...");
                        debug!("bundle: {rpc_bundle:?}");

                        let res = rpc_bundle.send(&bundle_client).await.map_err(|e| e.into());
                        if let Err(e) = res {
                            error_sender
                                .send(e)
                                .await
                                .unwrap_or_else(|e| trace!("failed to send error signal: {e:?}"));
                        } else {
                            success_sender
                                .send(())
                                .await
                                .unwrap_or_else(|e| trace!("failed to send success signal: {e:?}"));
                        }

                        let mut tx_handles = vec![];
                        for (tx, req) in signed_txs.into_iter().zip(reqs) {
                            let maybe_handle = callback_handler.on_tx_sent(
                                PendingTransactionConfig::new(*tx.tx_hash()),
                                &req,
                                extra.clone(),
                                Some(tx_handlers.clone()),
                            );
                            tx_handles.push(maybe_handle);
                        }
                        tx_handles
                    }
                };

                for handle in handles.into_iter().flatten() {
                    tokio::select! {
                        _ = cancel_token.cancelled() => {
                            debug!("cancelled spammer task");
                            return;
                        }
                        _ = handle => {
                            // wait for the task to finish
                        }
                    }
                }
            }));
        }

        Ok((tasks, error_receiver))
    }

    /// Send spam batches until the cursor is depleted.
    pub async fn execute_spammer<F: SpamCallback + 'static>(
        &mut self,
        cursor: &mut futures::stream::Take<Pin<Box<dyn Stream<Item = SpamTrigger> + Send>>>,
        tx_req_chunks: &[Vec<ExecutionRequest>],
        sent_tx_callback: Arc<F>,
    ) -> Result<()> {
        let mut tick = 0;
        while let Some(trigger) = cursor.next().await {
            let trigger = trigger.to_owned();
            // assign from addrs, nonces, and gas prices for this chunk of tx requests
            let payloads = self
                .prepare_spam(&tx_req_chunks[tick % tx_req_chunks.len().max(1)])
                .await?;
            let num_payloads = payloads.len();

            // initialize async context handlers
            let (success_sender, mut success_receiver) = tokio::sync::mpsc::channel(num_payloads);
            let (add_gas_sender, mut add_gas_receiver) = tokio::sync::mpsc::channel(num_payloads);
            let context = SpamContextHandler {
                success_send_tx: success_sender,
                add_gas: add_gas_sender,
            };

            // send this batch of spam txs
            let (spam_tasks, mut error_receiver) = self
                .execute_spam(trigger, payloads, sent_tx_callback.clone(), context)
                .await?;
            let mut num_tasks = spam_tasks.len();

            // wait for spam txs to finish sending
            for task in spam_tasks {
                tokio::select! {
                    res = task => {
                        if let Err(e) = res {
                            warn!("spam task failed: {e:?}");
                            num_tasks -= 1;
                        }
                    },
                    Some(err) = error_receiver.recv() => {
                        return Err(err);
                    }
                    _ = self.ctx.cancel_token.cancelled() => {
                        break;
                    }
                }
            }

            // wait for the on_batch_sent callback to finish
            if let Some(task) = sent_tx_callback.on_batch_sent() {
                task.await
                    .map_err(|e| ContenderError::with_err(e, "on_batch_sent callback failed"))??;
            }

            info!("[{tick}] executed {num_tasks} spam tasks");

            // increase gas price if needed
            add_gas_receiver.close();
            let starting_gas_adder = self.ctx.gas_price_adder;
            while let Some(gas) = add_gas_receiver.recv().await {
                if self.ctx.gas_price_adder >= gas as i128 + starting_gas_adder {
                    continue;
                }
                debug!("incrementing gas price by {gas}");
                self.ctx.add_to_gas_price(gas as i128);
            }

            // decrease gas price if all txs were sent successfully
            success_receiver.close();
            let mut success_count = 0;
            while success_receiver.recv().await.is_some() {
                success_count += 1;
            }
            if success_count == num_payloads {
                info!("all spam txs sent successfully");
                if self.ctx.gas_price_adder > 0 {
                    // remove 10% of the gas price adder
                    self.ctx.add_to_gas_price(self.ctx.gas_price_adder / -10);
                }
            } else {
                warn!(
                    "some spam txs failed to send: {} / {}",
                    num_payloads - success_count,
                    num_payloads
                );
            }

            // increment tick to get next chunk of txs
            tick += 1;
        }

        Ok(())
    }

    fn format_setup_log(&self, tx_req: &NamedTxRequest) -> String {
        let to_address = tx_req.tx.to.unwrap_or_default();
        let to_address = to_address.to();

        // lookup name of contract if it exists
        let to_name = to_address.map(|a| {
            let named_tx = self.db.get_named_tx_by_address(a);
            named_tx
                .map(|t| t.map(|tt| tt.name).unwrap_or_default())
                .unwrap_or_default()
        });

        format!(
            "running setup: from={} to={} {}",
            tx_req
                .tx
                .from
                .as_ref()
                .map(|a| a.encode_hex())
                .unwrap_or_default(),
            if let Some(to) = to_name {
                to
            } else {
                to_address.map(|a| a.encode_hex()).unwrap_or_default()
            },
            if let Some(kind) = &tx_req.kind {
                format!("kind={kind}")
            } else {
                "".to_string()
            },
        )
    }

    /// Returns the maximum cost of a single spam transaction by creating a new scenario
    /// and running estimateGas calls to estimate the cost of the spam transactions.
    pub async fn get_max_spam_cost(&self, user_signers: &[PrivateKeySigner]) -> Result<U256> {
        // separate prometheus registry for simulations; anvil doesn't count!
        static PROM: OnceCell<prometheus::Registry> = OnceCell::const_new();
        static HIST: OnceCell<prometheus::HistogramVec> = OnceCell::const_new();
        let mut scenario = TestScenario::new(
            self.config.to_owned(),
            self.db.clone(),
            self.rand_seed.clone(),
            TestScenarioParams {
                rpc_url: self.rpc_url.clone(),
                builder_rpc_url: self.builder_rpc_url.clone(),
                signers: user_signers.to_owned(),
                agent_store: self.agent_store.clone(),
                tx_type: self.tx_type,
                bundle_type: self.bundle_type,
                pending_tx_timeout_secs: self.pending_tx_timeout_secs,
                extra_msg_handles: None,
            },
            None,
            (&PROM, &HIST).into(),
        )
        .await?;

        // load a sample of each spam tx from the scenario
        let txs = scenario
            .load_txs(PlanType::Spam(
                scenario
                    .config
                    .get_spam_steps()
                    .map(|s| s.len()) // take the number of spam txs from the testfile
                    .unwrap_or(0) as u64,
                |_named_req| {
                    // we can look at the named request here if needed
                    Ok(None)
                },
            ))
            .await?;
        let sample_txs = scenario
            .prepare_spam(&txs)
            .await?
            .iter()
            .map(|ex_payload| match ex_payload {
                ExecutionPayload::SignedTx(_envelope, tx_req) => vec![tx_req.to_owned()],
                ExecutionPayload::SignedTxBundle(_envelopes, tx_reqs) => tx_reqs
                    .iter()
                    .map(|tx| Box::new(tx.to_owned()))
                    .collect::<Vec<_>>(),
            })
            .collect::<Vec<_>>()
            .concat();

        let gas_price = scenario
            .rpc_client
            .get_gas_price()
            .await
            .map_err(|e| ContenderError::with_err(e, "failed to get gas price"))?;
        let blob_gas_price = get_blob_fee_maybe(&scenario.rpc_client).await;

        // get gas limit for each tx
        let mut prepared_sample_txs = vec![];
        for tx in sample_txs {
            let tx_req = tx.tx;
            let (prepared_req, _signer) = scenario
                .prepare_tx_request(&tx_req, gas_price, blob_gas_price)
                .await?;
            prepared_sample_txs.push(prepared_req);
        }

        // get the highest gas cost of all spam txs
        let highest_gas_cost = prepared_sample_txs
            .iter()
            .map(|tx| {
                let mut gas_price = tx.max_fee_per_gas.unwrap_or(tx.gas_price.unwrap_or(0));
                if let Some(priority_fee) = tx.max_priority_fee_per_gas {
                    gas_price += priority_fee;
                }
                U256::from(gas_price * tx.gas.unwrap_or(0) as u128) + tx.value.unwrap_or(U256::ZERO)
            })
            .max()
            .ok_or(ContenderError::SpamError(
                "failed to get max gas cost for spam txs",
                None,
            ))?;

        // we assume the highest possible cost to minimize the chances of running out of ETH mid-test
        Ok(highest_gas_cost)
    }

    pub async fn get_spam_tx_chunks(
        &self,
        txs_per_period: u64,
        num_periods: u64,
    ) -> Result<Vec<Vec<ExecutionRequest>>> {
        let tx_requests = self
            .load_txs(crate::generator::PlanType::Spam(
                txs_per_period * num_periods,
                |_named_req| Ok(None), // we can look at the named request here if needed
            ))
            .await?;
        Ok(tx_requests
            .chunks(txs_per_period as usize)
            .map(|chunk| chunk.to_vec())
            .collect::<_>())
    }

    pub async fn flush_tx_cache(&self, block_start: u64, run_id: u64) -> Result<()> {
        let mut block_counter = 0;
        // the number of blocks to check for stalled txs
        let block_timeout = ((self.pending_tx_timeout_secs / self.ctx.block_time_secs) + 1)
            // must be at least 2 blocks because otherwise we have nothing to compare
            .max(2);
        let mut cache_size_queue = vec![];
        cache_size_queue.resize(block_timeout as usize, 1);
        for msg_handle in self.msg_handles.values() {
            loop {
                let pending_txs = msg_handle
                    .flush_cache(run_id, block_start + block_counter as u64)
                    .await
                    .map_err(|e| ContenderError::with_err(e.deref(), "failed to flush cache"))?;
                cache_size_queue.rotate_right(1);
                cache_size_queue[0] = pending_txs.len();

                if pending_txs.is_empty() {
                    break;
                }

                let current_timestamp = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .expect("time went backwards")
                    .as_millis();

                // remove cached txs if the size hasn't changed for the last N blocks
                if cache_size_queue
                    .iter()
                    .all(|&size| size == cache_size_queue[0])
                {
                    warn!(
                        "Cache size has not changed for the last {block_timeout} blocks. Removing stalled txs...",
                    );

                    for tx in &pending_txs {
                        // only remove txs that have been waiting for > T seconds
                        if current_timestamp
                            > tx.start_timestamp_ms + (self.pending_tx_timeout_secs as u128 * 1000)
                        {
                            msg_handle.remove_cached_tx(tx.tx_hash).await.map_err(|e| {
                                ContenderError::with_err(
                                    e.deref(),
                                    "failed to remove tx from cache",
                                )
                            })?;
                        }
                    }
                }

                block_counter += 1;
            }
        }

        Ok(())
    }

    pub async fn dump_tx_cache(&self, run_id: u64) -> Result<()> {
        debug!("dumping tx cache...");

        for msg_handle in self.msg_handles.values() {
            let failed_txs = msg_handle
                .dump_cache(run_id)
                .await
                .map_err(|e| ContenderError::with_err(e.deref(), "failed to dump cache"))?;
            if !failed_txs.is_empty() {
                warn!(
                    "Failed to collect receipts for {} txs. Any valid txs sent may still land.",
                    failed_txs.len()
                );
            }
        }

        Ok(())
    }

    /// Collects latency metrics from the prometheus registry.
    /// Returns a map of RPC method names to a vector of latency buckets which represent (upper_bound_secs, cumulative_count).
    pub fn collect_latency_metrics(&self) -> BTreeMap<String, Vec<Bucket>> {
        let registry = self.prometheus.prom.get();
        let mut latency_map = BTreeMap::new();
        if let Some(registry) = registry {
            let metric_families = registry.gather();

            for mf in &metric_families {
                if mf.name() == RPC_REQUEST_LATENCY_ID {
                    for m in mf.get_metric() {
                        let mut latencies: Vec<Bucket> = vec![];
                        if m.label.is_empty() {
                            continue;
                        }
                        let label = m.label.first().expect("label");
                        if label.name() != "rpc_method" {
                            continue;
                        }
                        let hist = m.get_histogram();
                        for bucket in &hist.bucket {
                            if bucket.cumulative_count.is_none() {
                                continue;
                            }
                            let upper_bound = bucket.upper_bound();
                            let cumulative_count =
                                bucket.cumulative_count.expect("cumulative_count");

                            latencies.push((upper_bound, cumulative_count).into());
                        }
                        latency_map.insert(label.value().to_string(), latencies);
                    }
                }
            }
        }
        latency_map
    }
}

async fn sync_nonces(
    wallet_map: &HashMap<Address, EthereumWallet>,
    nonces: &mut HashMap<Address, u64>,
    rpc_client: &AnyProvider,
    setcode_signer_address: Address,
) -> Result<()> {
    let mut all_addrs = wallet_map.keys().copied().collect::<Vec<Address>>();
    all_addrs.push(setcode_signer_address);
    let mut tasks = vec![];
    let (sender, mut receiver) = tokio::sync::mpsc::channel::<(Address, u64)>(all_addrs.len() + 1);
    for addr in all_addrs {
        let send = sender.clone();
        let rpc_client = Arc::new(rpc_client.clone());
        tasks.push(tokio::task::spawn(async move {
            let nonce = rpc_client
                .get_transaction_count(addr)
                .await
                .map_err(|e| ContenderError::with_err(e, "failed to retrieve nonce from RPC"))?;
            send.send((addr, nonce))
                .await
                .map_err(|e| ContenderError::with_err(e, "(mpsc) failed to send nonce"))?;
            Ok::<_, ContenderError>(())
        }));
    }

    for task in tasks {
        if let Err(e) = task.await {
            warn!("failed to sync nonce: {e:?}");
        }
    }
    receiver.close();

    debug!("waiting for nonces to sync...");
    while let Some((addr, nonce)) = receiver.recv().await {
        nonces.insert(addr, nonce);
    }

    Ok(())
}

impl<D, S, P> Generator<String, D, P> for TestScenario<D, S, P>
where
    D: DbOps + Send + Sync,
    S: Seeder,
    P: PlanConfig<String> + Templater<String> + Send + Sync,
{
    fn get_db(&self) -> &D {
        self.db.as_ref()
    }

    fn get_templater(&self) -> &P {
        &self.config
    }

    fn get_plan_conf(&self) -> &impl PlanConfig<String> {
        &self.config
    }

    fn get_fuzz_seeder(&self) -> &impl Seeder {
        &self.rand_seed
    }

    fn get_agent_store(&self) -> &AgentStore {
        &self.agent_store
    }

    fn get_rpc_url(&self) -> String {
        self.rpc_url.to_string()
    }

    fn get_chain_id(&self) -> u64 {
        self.ctx.chain_id
    }

    fn get_rpc_provider(&self) -> &AnyProvider {
        &self.rpc_client
    }

    fn get_nonce_map(&self) -> &HashMap<Address, u64> {
        &self.nonces
    }

    fn get_setcode_signer(&self) -> &PrivateKeySigner {
        &self.setcode_signer
    }
}

struct SpamContextHandler {
    add_gas: tokio::sync::mpsc::Sender<u128>,
    success_send_tx: tokio::sync::mpsc::Sender<()>,
}

#[cfg(test)]
pub mod tests {
    use crate::agent_controller::AgentStore;
    use crate::db::MockDb;
    use crate::error::ContenderError;
    use crate::generator::named_txs::ExecutionRequest;
    use crate::generator::templater::Templater;
    use crate::generator::types::SpamRequest;
    use crate::generator::{types::PlanType, util::test::spawn_anvil, RandSeed};
    use crate::generator::{
        CompiledContract, CreateDefinition, FunctionCallDefinition, FuzzParam, Generator,
        PlanConfig,
    };
    use crate::spammer::util::test::get_test_signers;
    use crate::test_scenario::TestScenario;
    use crate::Result;
    use alloy::consensus::constants::GWEI_TO_WEI;
    use alloy::hex::ToHexExt;
    use alloy::node_bindings::{Anvil, AnvilInstance};
    use alloy::primitives::utils::format_ether;
    use alloy::primitives::{Address, U256};
    use alloy::providers::Provider;
    use contender_bundle_provider::bundle::BundleType;
    use std::collections::HashMap;
    use tokio::sync::OnceCell;

    use super::TestScenarioParams;

    // separate prometheus registry for simulations; anvil doesn't count!
    static PROM: OnceCell<prometheus::Registry> = OnceCell::const_new();
    static HIST: OnceCell<prometheus::HistogramVec> = OnceCell::const_new();

    #[derive(Clone)]
    pub struct MockConfig;

    pub const COUNTER_BYTECODE: &str =
        "0x608060405234801561001057600080fd5b5060f78061001f6000396000f3fe6080604052348015600f57600080fd5b5060043610603c5760003560e01c80633fb5c1cb1460415780638381f58a146053578063d09de08a14606d575b600080fd5b6051604c3660046083565b600055565b005b605b60005481565b60405190815260200160405180910390f35b6051600080549080607c83609b565b9190505550565b600060208284031215609457600080fd5b5035919050565b60006001820160ba57634e487b7160e01b600052601160045260246000fd5b506001019056fea264697066735822122010f3077836fb83a22ad708a23102f2b487523767e1afef5a93c614619001648b64736f6c63430008170033";
    pub const UNI_V2_FACTORY_BYTECODE: &str = "0x608060405234801561001057600080fd5b506040516136863803806136868339818101604052602081101561003357600080fd5b5051600180546001600160a01b0319166001600160a01b03909216919091179055613623806100636000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063a2e74af61161005b578063a2e74af6146100fd578063c9c6539614610132578063e6a439051461016d578063f46901ed146101a857610088565b8063017e7e581461008d578063094b7415146100be5780631e3dd18b146100c6578063574f2ba3146100e3575b600080fd5b6100956101db565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b6100956101f7565b610095600480360360208110156100dc57600080fd5b5035610213565b6100eb610247565b60408051918252519081900360200190f35b6101306004803603602081101561011357600080fd5b503573ffffffffffffffffffffffffffffffffffffffff1661024d565b005b6100956004803603604081101561014857600080fd5b5073ffffffffffffffffffffffffffffffffffffffff8135811691602001351661031a565b6100956004803603604081101561018357600080fd5b5073ffffffffffffffffffffffffffffffffffffffff8135811691602001351661076d565b610130600480360360208110156101be57600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166107a0565b60005473ffffffffffffffffffffffffffffffffffffffff1681565b60015473ffffffffffffffffffffffffffffffffffffffff1681565b6003818154811061022057fe5b60009182526020909120015473ffffffffffffffffffffffffffffffffffffffff16905081565b60035490565b60015473ffffffffffffffffffffffffffffffffffffffff1633146102d357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f556e697377617056323a20464f5242494444454e000000000000000000000000604482015290519081900360640190fd5b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60008173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156103b757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f556e697377617056323a204944454e544943414c5f4144445245535345530000604482015290519081900360640190fd5b6000808373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16106103f45783856103f7565b84845b909250905073ffffffffffffffffffffffffffffffffffffffff821661047e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f556e697377617056323a205a45524f5f41444452455353000000000000000000604482015290519081900360640190fd5b73ffffffffffffffffffffffffffffffffffffffff82811660009081526002602090815260408083208585168452909152902054161561051f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f556e697377617056323a20504149525f45584953545300000000000000000000604482015290519081900360640190fd5b6060604051806020016105319061086d565b6020820181038252601f19601f82011660405250905060008383604051602001808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1660601b81526014018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1660601b815260140192505050604051602081830303815290604052805190602001209050808251602084016000f5604080517f485cc95500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8781166004830152868116602483015291519297509087169163485cc9559160448082019260009290919082900301818387803b15801561065e57600080fd5b505af1158015610672573d6000803e3d6000fd5b5050505073ffffffffffffffffffffffffffffffffffffffff84811660008181526002602081815260408084208987168086529083528185208054978d167fffffffffffffffffffffffff000000000000000000000000000000000000000098891681179091559383528185208686528352818520805488168517905560038054600181018255958190527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b90950180549097168417909655925483519283529082015281517f0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31afa28d0e9929181900390910190a35050505092915050565b600260209081526000928352604080842090915290825290205473ffffffffffffffffffffffffffffffffffffffff1681565b60015473ffffffffffffffffffffffffffffffffffffffff16331461082657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f556e697377617056323a20464f5242494444454e000000000000000000000000604482015290519081900360640190fd5b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b612d748061087b8339019056fe60806040526001600c5534801561001557600080fd5b506040514690806052612d228239604080519182900360520182208282018252600a8352692ab734b9bbb0b8102b1960b11b6020938401528151808301835260018152603160f81b908401528151808401919091527fbfcc8ef98ffbf7b6c3fec7bf5185b566b9863e35a9d83acd49ad6824b5969738818301527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6606082015260808101949094523060a0808601919091528151808603909101815260c09094019052825192019190912060035550600580546001600160a01b03191633179055612c1d806101056000396000f3fe608060405234801561001057600080fd5b50600436106101b95760003560e01c80636a627842116100f9578063ba9a7a5611610097578063d21220a711610071578063d21220a7146105da578063d505accf146105e2578063dd62ed3e14610640578063fff6cae91461067b576101b9565b8063ba9a7a5614610597578063bc25cf771461059f578063c45a0155146105d2576101b9565b80637ecebe00116100d35780637ecebe00146104d757806389afcb441461050a57806395d89b4114610556578063a9059cbb1461055e576101b9565b80636a6278421461046957806370a082311461049c5780637464fc3d146104cf576101b9565b806323b872dd116101665780633644e515116101405780633644e51514610416578063485cc9551461041e5780635909c0d5146104595780635a3d549314610461576101b9565b806323b872dd146103ad57806330adf81f146103f0578063313ce567146103f8576101b9565b8063095ea7b311610197578063095ea7b3146103155780630dfe16811461036257806318160ddd14610393576101b9565b8063022c0d9f146101be57806306fdde03146102595780630902f1ac146102d6575b600080fd5b610257600480360360808110156101d457600080fd5b81359160208101359173ffffffffffffffffffffffffffffffffffffffff604083013516919081019060808101606082013564010000000081111561021857600080fd5b82018360208201111561022a57600080fd5b8035906020019184600183028401116401000000008311171561024c57600080fd5b509092509050610683565b005b610261610d57565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561029b578181015183820152602001610283565b50505050905090810190601f1680156102c85780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6102de610d90565b604080516dffffffffffffffffffffffffffff948516815292909316602083015263ffffffff168183015290519081900360600190f35b61034e6004803603604081101561032b57600080fd5b5073ffffffffffffffffffffffffffffffffffffffff8135169060200135610de5565b604080519115158252519081900360200190f35b61036a610dfc565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b61039b610e18565b60408051918252519081900360200190f35b61034e600480360360608110156103c357600080fd5b5073ffffffffffffffffffffffffffffffffffffffff813581169160208101359091169060400135610e1e565b61039b610efd565b610400610f21565b6040805160ff9092168252519081900360200190f35b61039b610f26565b6102576004803603604081101561043457600080fd5b5073ffffffffffffffffffffffffffffffffffffffff81358116916020013516610f2c565b61039b611005565b61039b61100b565b61039b6004803603602081101561047f57600080fd5b503573ffffffffffffffffffffffffffffffffffffffff16611011565b61039b600480360360208110156104b257600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166113cb565b61039b6113dd565b61039b600480360360208110156104ed57600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166113e3565b61053d6004803603602081101561052057600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166113f5565b6040805192835260208301919091528051918290030190f35b610261611892565b61034e6004803603604081101561057457600080fd5b5073ffffffffffffffffffffffffffffffffffffffff81351690602001356118cb565b61039b6118d8565b610257600480360360208110156105b557600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166118de565b61036a611ad4565b61036a611af0565b610257600480360360e08110156105f857600080fd5b5073ffffffffffffffffffffffffffffffffffffffff813581169160208101359091169060408101359060608101359060ff6080820135169060a08101359060c00135611b0c565b61039b6004803603604081101561065657600080fd5b5073ffffffffffffffffffffffffffffffffffffffff81358116916020013516611dd8565b610257611df5565b600c546001146106f457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c55841515806107075750600084115b61075c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526025815260200180612b2f6025913960400191505060405180910390fd5b600080610767610d90565b5091509150816dffffffffffffffffffffffffffff168710801561079a5750806dffffffffffffffffffffffffffff1686105b6107ef576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526021815260200180612b786021913960400191505060405180910390fd5b600654600754600091829173ffffffffffffffffffffffffffffffffffffffff91821691908116908916821480159061085457508073ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff1614155b6108bf57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f556e697377617056323a20494e56414c49445f544f0000000000000000000000604482015290519081900360640190fd5b8a156108d0576108d0828a8d611fdb565b89156108e1576108e1818a8c611fdb565b86156109c3578873ffffffffffffffffffffffffffffffffffffffff166310d1e85c338d8d8c8c6040518663ffffffff1660e01b8152600401808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f8201169050808301925050509650505050505050600060405180830381600087803b1580156109aa57600080fd5b505af11580156109be573d6000803e3d6000fd5b505050505b604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905173ffffffffffffffffffffffffffffffffffffffff8416916370a08231916024808301926020929190829003018186803b158015610a2f57600080fd5b505afa158015610a43573d6000803e3d6000fd5b505050506040513d6020811015610a5957600080fd5b5051604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905191955073ffffffffffffffffffffffffffffffffffffffff8316916370a0823191602480820192602092909190829003018186803b158015610acb57600080fd5b505afa158015610adf573d6000803e3d6000fd5b505050506040513d6020811015610af557600080fd5b5051925060009150506dffffffffffffffffffffffffffff85168a90038311610b1f576000610b35565b89856dffffffffffffffffffffffffffff160383035b9050600089856dffffffffffffffffffffffffffff16038311610b59576000610b6f565b89856dffffffffffffffffffffffffffff160383035b90506000821180610b805750600081115b610bd5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526024815260200180612b546024913960400191505060405180910390fd5b6000610c09610beb84600363ffffffff6121e816565b610bfd876103e863ffffffff6121e816565b9063ffffffff61226e16565b90506000610c21610beb84600363ffffffff6121e816565b9050610c59620f4240610c4d6dffffffffffffffffffffffffffff8b8116908b1663ffffffff6121e816565b9063ffffffff6121e816565b610c69838363ffffffff6121e816565b1015610cd657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f556e697377617056323a204b0000000000000000000000000000000000000000604482015290519081900360640190fd5b5050610ce4848488886122e0565b60408051838152602081018390528082018d9052606081018c9052905173ffffffffffffffffffffffffffffffffffffffff8b169133917fd78ad95fa46c994b6551d0da85fc275fe613ce37657fb8d5e3d130840159d8229181900360800190a350506001600c55505050505050505050565b6040518060400160405280600a81526020017f556e69737761702056320000000000000000000000000000000000000000000081525081565b6008546dffffffffffffffffffffffffffff808216926e0100000000000000000000000000008304909116917c0100000000000000000000000000000000000000000000000000000000900463ffffffff1690565b6000610df233848461259c565b5060015b92915050565b60065473ffffffffffffffffffffffffffffffffffffffff1681565b60005481565b73ffffffffffffffffffffffffffffffffffffffff831660009081526002602090815260408083203384529091528120547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff14610ee85773ffffffffffffffffffffffffffffffffffffffff84166000908152600260209081526040808320338452909152902054610eb6908363ffffffff61226e16565b73ffffffffffffffffffffffffffffffffffffffff851660009081526002602090815260408083203384529091529020555b610ef384848461260b565b5060019392505050565b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c981565b601281565b60035481565b60055473ffffffffffffffffffffffffffffffffffffffff163314610fb257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f556e697377617056323a20464f5242494444454e000000000000000000000000604482015290519081900360640190fd5b6006805473ffffffffffffffffffffffffffffffffffffffff9384167fffffffffffffffffffffffff00000000000000000000000000000000000000009182161790915560078054929093169116179055565b60095481565b600a5481565b6000600c5460011461108457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c81905580611094610d90565b50600654604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905193955091935060009273ffffffffffffffffffffffffffffffffffffffff909116916370a08231916024808301926020929190829003018186803b15801561110e57600080fd5b505afa158015611122573d6000803e3d6000fd5b505050506040513d602081101561113857600080fd5b5051600754604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905192935060009273ffffffffffffffffffffffffffffffffffffffff909216916370a0823191602480820192602092909190829003018186803b1580156111b157600080fd5b505afa1580156111c5573d6000803e3d6000fd5b505050506040513d60208110156111db57600080fd5b505190506000611201836dffffffffffffffffffffffffffff871663ffffffff61226e16565b90506000611225836dffffffffffffffffffffffffffff871663ffffffff61226e16565b9050600061123387876126ec565b600054909150806112705761125c6103e8610bfd611257878763ffffffff6121e816565b612878565b985061126b60006103e86128ca565b6112cd565b6112ca6dffffffffffffffffffffffffffff8916611294868463ffffffff6121e816565b8161129b57fe5b046dffffffffffffffffffffffffffff89166112bd868563ffffffff6121e816565b816112c457fe5b0461297a565b98505b60008911611326576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526028815260200180612bc16028913960400191505060405180910390fd5b6113308a8a6128ca565b61133c86868a8a6122e0565b811561137e5760085461137a906dffffffffffffffffffffffffffff808216916e01000000000000000000000000000090041663ffffffff6121e816565b600b555b6040805185815260208101859052815133927f4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f928290030190a250506001600c5550949695505050505050565b60016020526000908152604090205481565b600b5481565b60046020526000908152604090205481565b600080600c5460011461146957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c81905580611479610d90565b50600654600754604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905194965092945073ffffffffffffffffffffffffffffffffffffffff9182169391169160009184916370a08231916024808301926020929190829003018186803b1580156114fb57600080fd5b505afa15801561150f573d6000803e3d6000fd5b505050506040513d602081101561152557600080fd5b5051604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905191925060009173ffffffffffffffffffffffffffffffffffffffff8516916370a08231916024808301926020929190829003018186803b15801561159957600080fd5b505afa1580156115ad573d6000803e3d6000fd5b505050506040513d60208110156115c357600080fd5b5051306000908152600160205260408120549192506115e288886126ec565b600054909150806115f9848763ffffffff6121e816565b8161160057fe5b049a5080611614848663ffffffff6121e816565b8161161b57fe5b04995060008b11801561162e575060008a115b611683576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526028815260200180612b996028913960400191505060405180910390fd5b61168d3084612992565b611698878d8d611fdb565b6116a3868d8c611fdb565b604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905173ffffffffffffffffffffffffffffffffffffffff8916916370a08231916024808301926020929190829003018186803b15801561170f57600080fd5b505afa158015611723573d6000803e3d6000fd5b505050506040513d602081101561173957600080fd5b5051604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905191965073ffffffffffffffffffffffffffffffffffffffff8816916370a0823191602480820192602092909190829003018186803b1580156117ab57600080fd5b505afa1580156117bf573d6000803e3d6000fd5b505050506040513d60208110156117d557600080fd5b505193506117e585858b8b6122e0565b811561182757600854611823906dffffffffffffffffffffffffffff808216916e01000000000000000000000000000090041663ffffffff6121e816565b600b555b604080518c8152602081018c9052815173ffffffffffffffffffffffffffffffffffffffff8f169233927fdccd412f0b1252819cb1fd330b93224ca42612892bb3f4f789976e6d81936496929081900390910190a35050505050505050506001600c81905550915091565b6040518060400160405280600681526020017f554e492d5632000000000000000000000000000000000000000000000000000081525081565b6000610df233848461260b565b6103e881565b600c5460011461194f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c55600654600754600854604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905173ffffffffffffffffffffffffffffffffffffffff9485169490931692611a2b9285928792611a26926dffffffffffffffffffffffffffff169185916370a0823191602480820192602092909190829003018186803b1580156119ee57600080fd5b505afa158015611a02573d6000803e3d6000fd5b505050506040513d6020811015611a1857600080fd5b50519063ffffffff61226e16565b611fdb565b600854604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051611aca9284928792611a26926e01000000000000000000000000000090046dffffffffffffffffffffffffffff169173ffffffffffffffffffffffffffffffffffffffff8616916370a0823191602480820192602092909190829003018186803b1580156119ee57600080fd5b50506001600c5550565b60055473ffffffffffffffffffffffffffffffffffffffff1681565b60075473ffffffffffffffffffffffffffffffffffffffff1681565b42841015611b7b57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f556e697377617056323a20455850495245440000000000000000000000000000604482015290519081900360640190fd5b60035473ffffffffffffffffffffffffffffffffffffffff80891660008181526004602090815260408083208054600180820190925582517f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98186015280840196909652958d166060860152608085018c905260a085019590955260c08085018b90528151808603909101815260e0850182528051908301207f19010000000000000000000000000000000000000000000000000000000000006101008601526101028501969096526101228085019690965280518085039096018652610142840180825286519683019690962095839052610162840180825286905260ff89166101828501526101a284018890526101c28401879052519193926101e2808201937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081019281900390910190855afa158015611cdc573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff811615801590611d5757508873ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b611dc257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f556e697377617056323a20494e56414c49445f5349474e415455524500000000604482015290519081900360640190fd5b611dcd89898961259c565b505050505050505050565b600260209081526000928352604080842090915290825290205481565b600c54600114611e6657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c55600654604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051611fd49273ffffffffffffffffffffffffffffffffffffffff16916370a08231916024808301926020929190829003018186803b158015611edd57600080fd5b505afa158015611ef1573d6000803e3d6000fd5b505050506040513d6020811015611f0757600080fd5b5051600754604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905173ffffffffffffffffffffffffffffffffffffffff909216916370a0823191602480820192602092909190829003018186803b158015611f7a57600080fd5b505afa158015611f8e573d6000803e3d6000fd5b505050506040513d6020811015611fa457600080fd5b50516008546dffffffffffffffffffffffffffff808216916e0100000000000000000000000000009004166122e0565b6001600c55565b604080518082018252601981527f7472616e7366657228616464726573732c75696e743235362900000000000000602091820152815173ffffffffffffffffffffffffffffffffffffffff85811660248301526044808301869052845180840390910181526064909201845291810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb000000000000000000000000000000000000000000000000000000001781529251815160009460609489169392918291908083835b602083106120e157805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920191602091820191016120a4565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114612143576040519150601f19603f3d011682016040523d82523d6000602084013e612148565b606091505b5091509150818015612176575080511580612176575080806020019051602081101561217357600080fd5b50515b6121e157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f556e697377617056323a205452414e534645525f4641494c4544000000000000604482015290519081900360640190fd5b5050505050565b60008115806122035750508082028282828161220057fe5b04145b610df657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f64732d6d6174682d6d756c2d6f766572666c6f77000000000000000000000000604482015290519081900360640190fd5b80820382811115610df657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f64732d6d6174682d7375622d756e646572666c6f770000000000000000000000604482015290519081900360640190fd5b6dffffffffffffffffffffffffffff841180159061230c57506dffffffffffffffffffffffffffff8311155b61237757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f556e697377617056323a204f564552464c4f5700000000000000000000000000604482015290519081900360640190fd5b60085463ffffffff428116917c0100000000000000000000000000000000000000000000000000000000900481168203908116158015906123c757506dffffffffffffffffffffffffffff841615155b80156123e257506dffffffffffffffffffffffffffff831615155b15612492578063ffffffff16612425856123fb86612a57565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff169063ffffffff612a7b16565b600980547bffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092169290920201905563ffffffff8116612465846123fb87612a57565b600a80547bffffffffffffffffffffffffffffffffffffffffffffffffffffffff92909216929092020190555b600880547fffffffffffffffffffffffffffffffffffff0000000000000000000000000000166dffffffffffffffffffffffffffff888116919091177fffffffff0000000000000000000000000000ffffffffffffffffffffffffffff166e0100000000000000000000000000008883168102919091177bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167c010000000000000000000000000000000000000000000000000000000063ffffffff871602179283905560408051848416815291909304909116602082015281517f1c411e9a96e071241c2f21f7726b17ae89e3cab4c78be50e062b03a9fffbbad1929181900390910190a1505050505050565b73ffffffffffffffffffffffffffffffffffffffff808416600081815260026020908152604080832094871680845294825291829020859055815185815291517f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259281900390910190a3505050565b73ffffffffffffffffffffffffffffffffffffffff8316600090815260016020526040902054612641908263ffffffff61226e16565b73ffffffffffffffffffffffffffffffffffffffff8085166000908152600160205260408082209390935590841681522054612683908263ffffffff612abc16565b73ffffffffffffffffffffffffffffffffffffffff80841660008181526001602090815260409182902094909455805185815290519193928716927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef92918290030190a3505050565b600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663017e7e586040518163ffffffff1660e01b815260040160206040518083038186803b15801561275757600080fd5b505afa15801561276b573d6000803e3d6000fd5b505050506040513d602081101561278157600080fd5b5051600b5473ffffffffffffffffffffffffffffffffffffffff821615801594509192509061286457801561285f5760006127d86112576dffffffffffffffffffffffffffff88811690881663ffffffff6121e816565b905060006127e583612878565b90508082111561285c576000612813612804848463ffffffff61226e16565b6000549063ffffffff6121e816565b905060006128388361282c86600563ffffffff6121e816565b9063ffffffff612abc16565b9050600081838161284557fe5b04905080156128585761285887826128ca565b5050505b50505b612870565b8015612870576000600b555b505092915050565b600060038211156128bb575080600160028204015b818110156128b5578091506002818285816128a457fe5b0401816128ad57fe5b04905061288d565b506128c5565b81156128c5575060015b919050565b6000546128dd908263ffffffff612abc16565b600090815573ffffffffffffffffffffffffffffffffffffffff8316815260016020526040902054612915908263ffffffff612abc16565b73ffffffffffffffffffffffffffffffffffffffff831660008181526001602090815260408083209490945583518581529351929391927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9281900390910190a35050565b6000818310612989578161298b565b825b9392505050565b73ffffffffffffffffffffffffffffffffffffffff82166000908152600160205260409020546129c8908263ffffffff61226e16565b73ffffffffffffffffffffffffffffffffffffffff831660009081526001602052604081209190915554612a02908263ffffffff61226e16565b600090815560408051838152905173ffffffffffffffffffffffffffffffffffffffff8516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef919081900360200190a35050565b6dffffffffffffffffffffffffffff166e0100000000000000000000000000000290565b60006dffffffffffffffffffffffffffff82167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff841681612ab457fe5b049392505050565b80820182811015610df657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f64732d6d6174682d6164642d6f766572666c6f77000000000000000000000000604482015290519081900360640190fdfe556e697377617056323a20494e53554646494349454e545f4f55545055545f414d4f554e54556e697377617056323a20494e53554646494349454e545f494e5055545f414d4f554e54556e697377617056323a20494e53554646494349454e545f4c4951554944495459556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e4544556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e544544a265627a7a723158207dca18479e58487606bf70c79e44d8dee62353c9ee6d01f9a9d70885b8765f2264736f6c63430005100032454950373132446f6d61696e28737472696e67206e616d652c737472696e672076657273696f6e2c75696e7432353620636861696e49642c6164647265737320766572696679696e67436f6e747261637429a265627a7a723158202760f92d7fa1db6f5aa16307bad65df4ebcc8550c4b1f03755ab8dfd830c178f64736f6c63430005100032000000000000000000000000{_sender}";

    impl PlanConfig<String> for MockConfig {
        fn get_env(&self) -> Result<HashMap<String, String>> {
            Ok(HashMap::<String, String>::from_iter([
                ("test1".to_owned(), "0xbeef".to_owned()),
                ("test2".to_owned(), "0x9001".to_owned()),
            ]))
        }

        fn get_create_steps(&self) -> Result<Vec<CreateDefinition>> {
            Ok(vec![
                CreateDefinition {
                    contract: CompiledContract {
                        bytecode: COUNTER_BYTECODE.to_string(),
                        name: "test_counter2".to_string(),
                    },
                    from: None,
                    from_pool: Some("admin1".to_owned()),
                },
                CreateDefinition {
                    contract: CompiledContract {
                        bytecode: UNI_V2_FACTORY_BYTECODE.to_string(),
                        name: "univ2_factory".to_string(),
                    },
                    from: None,
                    from_pool: Some("admin2".to_owned()),
                },
            ])
        }

        fn get_setup_steps(&self) -> Result<Vec<FunctionCallDefinition>> {
            Ok(vec![
                FunctionCallDefinition::new("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D")
                    .with_from("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266")
                    .with_value(U256::from(4096))
                    .with_signature("swap(uint256 x, uint256 y, address a, bytes b)")
                    .with_args(&[
                        "1".to_owned(),
                        "2".to_owned(),
                        Address::repeat_byte(0x11).encode_hex(),
                        "0xdead".to_owned(),
                    ]),
                FunctionCallDefinition::new("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D")
                    .with_from("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266")
                    .with_value(U256::from(0x1000))
                    .with_signature("swap(uint256 x, uint256 y, address a, bytes b)")
                    .with_args(&[
                        "1".to_owned(),
                        "2".to_owned(),
                        Address::repeat_byte(0x11).encode_hex(),
                        "0xbeef".to_owned(),
                    ]),
                FunctionCallDefinition::new("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D")
                    .with_from_pool("pool1")
                    .with_signature("increment()"),
            ])
        }

        fn get_spam_steps(&self) -> Result<Vec<SpamRequest>> {
            Ok(vec![
                SpamRequest::Tx(
                    FunctionCallDefinition::new("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D")
                        .with_from_pool("pool1")
                        .with_signature("swap(uint256 x, uint256 y, address a, bytes b)")
                        .with_args(&[
                            "1".to_owned(),
                            "2".to_owned(),
                            // {_sender} will be replaced with the `from` address
                            "{_sender}".to_owned(),
                            "0xd00d".to_owned(),
                        ])
                        .with_fuzz(&[FuzzParam {
                            param: Some("x".to_string()),
                            value: None,
                            min: None,
                            max: None,
                        }])
                        .into(),
                ),
                SpamRequest::Tx(
                    FunctionCallDefinition::new("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D")
                        .with_from_pool("pool2")
                        .with_signature("swap(uint256 x, uint256 y, address a, bytes b)")
                        .with_args(&[
                            "1".to_owned(),
                            "2".to_owned(),
                            // {_sender} will be replaced with the `from` address
                            "{_sender}".to_owned(),
                            "0xd00d".to_owned(),
                        ])
                        .with_fuzz(&[FuzzParam {
                            param: Some("x".to_string()),
                            value: None,
                            min: None,
                            max: None,
                        }])
                        .into(),
                ),
                SpamRequest::Tx(
                    FunctionCallDefinition::new("0x00000000000000000000000000000000f007ba11")
                        .with_from_pool("pool2")
                        .with_signature("swap(uint256 x, uint256 y, address a, bytes b)")
                        .with_args(&[
                            "1".to_owned(),
                            "2".to_owned(),
                            // {_sender} will be replaced with the `from` address
                            "{_sender}".to_owned(),
                            "0xd00d".to_owned(),
                        ])
                        .with_fuzz(&[FuzzParam {
                            param: Some("x".to_string()),
                            value: None,
                            min: None,
                            max: None,
                        }])
                        .with_gas_limit(100_000)
                        .into(),
                ),
            ])
        }
    }

    impl Templater<String> for MockConfig {
        fn copy_end(&self, input: &str, _last_end: usize) -> String {
            input.to_owned()
        }
        fn replace_placeholders(
            &self,
            input: &str,
            _placeholder_map: &std::collections::HashMap<String, String>,
        ) -> String {
            input.to_owned()
        }
        fn terminator_start(&self, _input: &str) -> Option<usize> {
            None
        }
        fn terminator_end(&self, _input: &str) -> Option<usize> {
            None
        }
        fn num_placeholders(&self, _input: &str) -> usize {
            0
        }
        fn find_key(&self, _input: &str) -> Option<(String, usize)> {
            None
        }
    }

    pub async fn get_test_scenario(
        anvil: &AnvilInstance,
        txs_per_duration: u64,
        builder_anvil: Option<&AnvilInstance>,
    ) -> std::result::Result<TestScenario<MockDb, RandSeed, MockConfig>, Box<dyn std::error::Error>>
    {
        let seed = RandSeed::new();
        let tx_type = alloy::consensus::TxType::Eip1559;
        let bundle_type = BundleType::default();
        let signers = get_test_signers();
        let fund_amount_eth = 25.0;

        println!("anvil endpoint: {}", anvil.endpoint_url());

        let mut agents = AgentStore::new();
        let config = MockConfig;
        let num_pools = config.get_spam_pools().len().max(1) as u64;
        println!("spam pools: {num_pools}, txs_per_duration: {txs_per_duration}");
        agents.init(
            &["pool1", "pool2"],
            (txs_per_duration / num_pools) as usize,
            &seed,
        );
        agents.init(&["admin1", "admin2"], 1, &seed);

        let mut scenario = TestScenario::new(
            config,
            MockDb.into(),
            seed.to_owned(),
            TestScenarioParams {
                rpc_url: anvil.endpoint_url(),
                builder_rpc_url: builder_anvil.map(|anvil| anvil.endpoint_url()),
                signers: signers.to_owned(),
                agent_store: agents,
                tx_type,
                bundle_type,
                pending_tx_timeout_secs: 12,
                extra_msg_handles: None,
            },
            None,
            (&PROM, &HIST).into(),
        )
        .await?;

        let fund_amount_wei = U256::from(fund_amount_eth * 1e18);
        println!("fund_amount_wei: {fund_amount_wei}");
        println!("fund_amount_eth: {fund_amount_eth}");
        println!("fund_amount eth: {}", format_ether(fund_amount_wei));

        for (name, agent) in scenario.agent_store.all_agents() {
            println!(
                "funding agent: {name} (num signers: {})",
                agent.signers.len()
            );
            let funder_balance = scenario
                .rpc_client
                .get_balance(anvil.wallet().unwrap().default_signer().address())
                .await
                .unwrap();
            println!("funder balance: {}", format_ether(funder_balance));
            agent
                .fund_signers(&signers[0], fund_amount_wei, scenario.rpc_client.clone())
                .await
                .unwrap();
        }

        scenario.ctx.add_to_gas_price(GWEI_TO_WEI as i128 * 10);

        Ok(scenario)
    }

    #[tokio::test]
    async fn it_creates_scenarios() -> std::result::Result<(), Box<dyn std::error::Error>> {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, None).await?;

        let create_txs = scenario
            .load_txs(PlanType::Create(|tx| {
                println!("create tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await?;
        assert_eq!(create_txs.len(), 2);

        let setup_txs = scenario
            .load_txs(PlanType::Setup(|tx| {
                println!("setup tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await?;
        assert_eq!(setup_txs.len(), 3);

        let spam_txs = scenario
            .load_txs(PlanType::Spam(20, |tx| {
                println!("spam tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await?;

        // should round up to nearest multiple of 3 (3 spam steps in config, 20 txs requested)
        assert_eq!(spam_txs.len(), 21);
        Ok(())
    }

    #[tokio::test]
    async fn gas_limit_override_works() {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, None).await.unwrap();
        let spam_txs = scenario
            .load_txs(PlanType::Spam(20, |tx| {
                println!("spam tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await
            .unwrap();
        let tx = spam_txs
            .iter()
            .find(|tx| match tx {
                ExecutionRequest::Tx(tx) => {
                    *tx.tx.to.unwrap().to().unwrap()
                        == "0x00000000000000000000000000000000f007ba11"
                            .parse::<Address>()
                            .unwrap()
                }
                _ => false,
            })
            .unwrap();
        match tx {
            ExecutionRequest::Tx(tx) => {
                assert_eq!(tx.tx.gas, Some(100_000));
            }
            _ => panic!("expected tx"),
        }
    }

    #[tokio::test]
    async fn fncall_replaces_sender_placeholder_with_from_address() {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, None).await.unwrap();

        let spam_txs = scenario
            .load_txs(PlanType::Spam(10, |tx| {
                println!("spam tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await
            .unwrap();
        let spam_tx = &spam_txs[0];
        let tx = match spam_tx {
            ExecutionRequest::Tx(tx) => tx,
            _ => panic!("expected tx"),
        };
        let from = tx.tx.from.unwrap();
        let input = tx.tx.input.input.as_ref().unwrap();
        println!("input: {input}");
        println!("from: {}", from.encode_hex());
        assert!(input.encode_hex().contains(&from.encode_hex()));
    }

    #[tokio::test]
    async fn create_replaces_sender_placeholder_with_from_address() {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, None).await.unwrap();

        let txs = scenario
            .load_txs(PlanType::Create(|tx| {
                println!("create tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await
            .unwrap();

        // 2nd tx should have from address in its bytecode when we deploy it
        let sample_tx = &txs[1];
        let tx = match sample_tx {
            ExecutionRequest::Tx(tx) => tx,
            _ => panic!("expected tx"),
        };
        let from = tx.tx.from.unwrap();
        let input = tx.tx.input.input.as_ref().unwrap();
        println!("input: {input}");
        println!("from: {}", from.encode_hex());
        assert!(input.encode_hex().contains(&from.encode_hex()));
    }

    #[tokio::test]
    async fn create_steps_use_agent_signers() {
        let anvil = spawn_anvil();
        let mut scenario = get_test_scenario(&anvil, 10, None).await.unwrap();
        scenario.deploy_contracts().await.unwrap();

        // assert that the agent store has the correct number of signers
        let create_steps = scenario
            .load_txs(PlanType::Create(|_| Ok(None)))
            .await
            .unwrap();
        let mut used_agent_keys = 0;
        for step in create_steps {
            let tx = match step {
                ExecutionRequest::Tx(tx) => tx,
                _ => continue,
            };
            if tx.tx.from.is_some() {
                assert!(scenario.wallet_map.contains_key(&tx.tx.from.unwrap()));
            }
            let admin_pools = ["admin1", "admin2"];
            for pool in admin_pools {
                if scenario
                    .agent_store
                    .get_agent(pool)
                    .unwrap()
                    .signers
                    .iter()
                    .map(|s| s.address())
                    .collect::<Vec<_>>()
                    .contains(&tx.tx.from.unwrap())
                {
                    used_agent_keys += 1;
                }
            }
        }
        assert_eq!(used_agent_keys, 2);
    }

    #[tokio::test]
    async fn setup_steps_use_agent_signers() {
        let anvil = spawn_anvil();
        let mut scenario = get_test_scenario(&anvil, 10, None).await.unwrap();
        scenario.deploy_contracts().await.unwrap();
        let setup_steps = scenario
            .load_txs(PlanType::Setup(|_| Ok(None)))
            .await
            .unwrap();
        scenario.run_setup().await.unwrap();
        let mut used_agent_keys = 0;
        for step in setup_steps {
            let tx = match step {
                ExecutionRequest::Tx(tx) => tx,
                _ => continue,
            };
            let from = tx.tx.from.unwrap();
            assert!(scenario.wallet_map.contains_key(&from));
            assert!(scenario.agent_store.has_agent("pool1"));
            if scenario
                .agent_store
                .get_agent("pool1")
                .unwrap()
                .signers
                .iter()
                .map(|s| s.address())
                .collect::<Vec<_>>()
                .contains(&from)
            {
                used_agent_keys += 1;
            }
        }
        assert_eq!(used_agent_keys, 1);
    }

    #[tokio::test]
    async fn scenario_creates_contracts() {
        let anvil = spawn_anvil();
        let mut scenario = get_test_scenario(&anvil, 10, None).await.unwrap();
        let res = scenario.deploy_contracts().await;
        assert!(res.is_ok());
    }

    #[tokio::test]
    async fn scenario_runs_setup() {
        let anvil = spawn_anvil();
        let mut scenario = get_test_scenario(&anvil, 10, None).await.unwrap();
        scenario.deploy_contracts().await.unwrap();
        let res = scenario.run_setup().await;
        println!("{res:?}");
        assert!(res.is_ok());
    }

    #[tokio::test]
    async fn setup_cost_estimates_are_correct(
    ) -> std::result::Result<(), Box<dyn std::error::Error>> {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, None).await.unwrap();
        let cost = scenario.estimate_setup_cost().await?;
        let total_txs = scenario.config.get_setup_steps().unwrap().len()
            + scenario.config.get_create_steps().unwrap().len();
        let expected_cost_min = U256::from(GWEI_TO_WEI * 21000 * total_txs as u64); // assuming gas price is 1 gwei and txs are cheap
        assert!(cost > expected_cost_min);
        Ok(())
    }

    #[tokio::test]
    async fn all_tx_requests_are_contiguous() -> std::result::Result<(), Box<dyn std::error::Error>>
    {
        let anvil = spawn_anvil();
        let txs_per_duration = 50u64;
        let duration = 3;
        let mut scenario = get_test_scenario(&anvil, txs_per_duration, None).await?;

        // make tx chunks
        let tx_req_chunks = scenario
            .get_spam_tx_chunks(txs_per_duration, duration)
            .await?;

        // test chunk size & count
        assert_eq!(tx_req_chunks.len(), duration as usize);
        for chunk in tx_req_chunks.iter() {
            assert_eq!(chunk.len(), txs_per_duration as usize);
        }

        // prepare tx requests & collect them all into a single array
        let mut prepared_txs: Vec<crate::spammer::ExecutionPayload> = vec![];
        for chunk in tx_req_chunks {
            let tx_reqs = scenario.prepare_spam(&chunk).await?;
            prepared_txs.extend(tx_reqs);
        }

        // group prepared_txs by `from` address, then sort each group by nonce, then assert that all nonces are contiguous (no gaps)
        let mut grouped_txs = std::collections::HashMap::new();
        for tx in &prepared_txs {
            match tx {
                crate::spammer::ExecutionPayload::SignedTx(_, tx_req) => {
                    let from = tx_req.tx.from.unwrap();
                    let nonce = tx_req.tx.nonce.unwrap();
                    grouped_txs.entry(from).or_insert_with(Vec::new).push(nonce);
                }
                crate::spammer::ExecutionPayload::SignedTxBundle(_, _) => {
                    // ignore
                }
            }
        }
        for (from, nonces) in grouped_txs {
            let mut nonces = nonces;
            nonces.sort();
            let mut prev_nonce = nonces[0];
            let mut min_nonce = prev_nonce;
            let mut max_nonce = prev_nonce;
            for nonce in &nonces[1..] {
                assert_eq!(prev_nonce + 1, *nonce);
                prev_nonce = *nonce;
                if *nonce < min_nonce {
                    min_nonce = *nonce;
                }
                if *nonce > max_nonce {
                    max_nonce = *nonce;
                }
            }
            println!("({from}) min_nonce: {min_nonce}, max_nonce: {max_nonce}");
        }

        Ok(())
    }

    #[tokio::test]
    async fn new_scenario_rejects_mismatched_chain_ids() {
        let anvil = spawn_anvil();
        let anvil2 = Anvil::new().chain_id(12321).spawn();
        let scenario = get_test_scenario(&anvil, 10, Some(&anvil2)).await;

        if let Err(e) = scenario {
            println!("error: {e}");
            assert!(matches!(
                e.downcast_ref(),
                Some(ContenderError::SetupError(_, _))
            ));
            assert!(e.to_string().contains("chain id must be consistent"));
        } else {
            panic!("scenario should not return if chain IDs don't match");
        }
    }
}
