use crate::{
    agent_controller::AgentStore,
    buckets::Bucket,
    constants::{SETUP_SIM_END, SETUP_SIM_START},
    db::{DbOps, NamedTx},
    error::{Error, RuntimeErrorKind, RuntimeParamErrorKind},
    generator::named_txs::ExecutionRequest,
    generator::templater::Templater,
    generator::types::AnyProvider,
    generator::util::{complete_tx_request, generate_setcode_signer},
    generator::NamedTxRequest,
    generator::{seeder::Seeder, types::PlanType, Generator, PlanConfig},
    provider::{LoggingLayer, RPC_REQUEST_LATENCY_ID},
    spammer::tx_actor::TxActorHandle,
    spammer::{CallbackError, ExecutionPayload, RuntimeTxInfo, SpamCallback, SpamTrigger},
    util::{get_blob_fee_maybe, get_block_time, ExtraTxParams},
    Result,
};
use alloy::{
    consensus::constants::{ETH_TO_WEI, GWEI_TO_WEI},
    consensus::{Transaction, TxType},
    eips::eip2718::Encodable2718,
    eips::BlockId,
    hex::ToHexExt,
    network::{AnyNetwork, AnyTxEnvelope, EthereumWallet, TransactionBuilder},
    node_bindings::Anvil,
    primitives::utils::{format_ether, format_units},
    primitives::{keccak256, Address, Bytes, FixedBytes, TxKind, U256},
    providers::{DynProvider, PendingTransactionConfig, Provider, ProviderBuilder},
    rpc::client::ClientBuilder,
    rpc::types::TransactionRequest,
    serde::WithOtherFields,
    signers::local::{LocalSigner, PrivateKeySigner},
};
use alloy::{network::ReceiptResponse, transports::http::reqwest};
use contender_bundle_provider::{
    bundle::BundleType, bundle_provider::new_basic_bundle,
    revert_bundle::RevertProtectBundleRequest, BundleClient,
};
use contender_engine_provider::ControlChain;
use futures::{Stream, StreamExt};
use serde_json::json;
use std::{
    collections::{BTreeMap, HashMap},
    pin::Pin,
    str::FromStr,
    sync::Arc,
    time::{Duration, Instant},
};
use tokio::sync::OnceCell;
use tokio_util::sync::CancellationToken;
use tracing::{debug, info, trace, warn};

pub use alloy::transports::http::reqwest::Url;

#[derive(Clone)]
pub struct PrometheusCollector {
    prom: &'static OnceCell<prometheus::Registry>,
    hist: &'static OnceCell<prometheus::HistogramVec>,
}

impl Default for PrometheusCollector {
    fn default() -> Self {
        static PROM: OnceCell<prometheus::Registry> = OnceCell::const_new();
        static HIST: OnceCell<prometheus::HistogramVec> = OnceCell::const_new();
        Self {
            prom: &PROM,
            hist: &HIST,
        }
    }
}

impl
    From<(
        &'static OnceCell<prometheus::Registry>,
        &'static OnceCell<prometheus::HistogramVec>,
    )> for PrometheusCollector
{
    fn from(
        (prom, hist): (
            &'static OnceCell<prometheus::Registry>,
            &'static OnceCell<prometheus::HistogramVec>,
        ),
    ) -> Self {
        Self { prom, hist }
    }
}

/// A test scenario can be used to run a test with a specific configuration, database, and RPC provider.
#[derive(Clone)]
pub struct TestScenario<D, S, P>
where
    D: DbOps + Send + Sync + 'static,
    S: Seeder,
    P: PlanConfig<String> + Templater<String> + Send + Sync,
{
    pub config: P,
    pub db: Arc<D>,
    pub rpc_url: Url,
    pub builder_rpc_url: Option<Url>,
    pub auth_provider: Option<Arc<dyn ControlChain + Send + Sync + 'static>>,
    pub bundle_client: Option<Arc<BundleClient>>,
    pub rpc_client: Arc<AnyProvider>,
    pub rand_seed: S,
    /// Signers explicitly given by the user
    pub signer_map: HashMap<Address, PrivateKeySigner>,
    /// Accounts generated by the system
    pub agent_store: AgentStore,
    pub nonces: HashMap<Address, u64>,
    pub chain_id: u64,
    pub gas_limits: HashMap<FixedBytes<32>, u64>,
    pub msg_handles: HashMap<String, Arc<TxActorHandle>>,
    pub tx_type: TxType,
    pub bundle_type: BundleType,
    pub pending_tx_timeout_secs: u64,
    pub ctx: ExecutionContext,
    prometheus: PrometheusCollector,
    setcode_signer: PrivateKeySigner,
    pub redeploy: bool,
    /// Determines whether scenario.sync_nonces is called automatically after each spam run batch.
    pub should_sync_nonces: bool,
    /// Max num of eth_sendRawTransaction calls per json-rpc batch; 0 disables batching.
    pub rpc_batch_size: u64,
    pub num_rpc_batches_sent: u64,
    pub gas_price: Option<U256>,
}

pub struct TestScenarioParams {
    pub rpc_url: Url,
    pub builder_rpc_url: Option<Url>,
    pub signers: Vec<PrivateKeySigner>,
    pub agent_store: AgentStore,
    pub tx_type: TxType,
    pub pending_tx_timeout_secs: u64,
    pub bundle_type: BundleType,
    pub extra_msg_handles: Option<HashMap<String, Arc<TxActorHandle>>>,
    pub redeploy: bool,
    pub sync_nonces_after_batch: bool,
    pub rpc_batch_size: u64,
    pub gas_price: Option<U256>,
}

pub struct SpamRunContext<'a, F: SpamCallback + 'static> {
    pub gas_sender: &'a tokio::sync::mpsc::Sender<u128>,
    pub nonce_sender: &'a tokio::sync::mpsc::Sender<(Address, i32)>,
    pub success_sender: &'a tokio::sync::mpsc::Sender<()>,
    pub callback_handler: &'a F,
    pub tx_handlers: &'a HashMap<String, Arc<TxActorHandle>>,
    pub cancel_token: &'a CancellationToken,
}

#[derive(Clone, Debug)]
pub struct ExecutionContext {
    /// Adds this amount of wei per gas to the gas price given to each transaction. May be negative to subtract gas.
    gas_price_adder: i128,
    /// The amount of time between blocks on the target chain.
    pub block_time_secs: u64,
    /// Tells us when to terminate async tasks.
    pub cancel_token: CancellationToken,
    /// Chain ID for target chain.
    pub chain_id: u64,
    /// Genesis hash of target chain.
    pub genesis_hash: FixedBytes<32>,
}

impl ExecutionContext {
    pub fn add_to_gas_price(&mut self, amount: i128) {
        self.gas_price_adder += amount;
    }
}

struct DeployContractParams<'a, D: DbOps> {
    db: &'a D,
    tx_req: &'a NamedTxRequest,
    extra_tx_params: ExtraTxParams,
    tx_type: TxType,
    rpc_url: &'a Url,
    signer: &'a PrivateKeySigner,
    redeploy: bool,
    genesis_hash: FixedBytes<32>,
}

impl<D, S, P> TestScenario<D, S, P>
where
    D: DbOps + Send + Sync + 'static,
    S: Seeder + Send + Sync + Clone,
    P: PlanConfig<String> + Templater<String> + Send + Sync + Clone,
{
    pub async fn new(
        config: P,
        db: Arc<D>,
        rand_seed: S,
        params: TestScenarioParams,
        auth_provider: Option<Arc<dyn ControlChain + Send + Sync + 'static>>,
        prometheus: PrometheusCollector,
    ) -> Result<Self> {
        let TestScenarioParams {
            rpc_url,
            builder_rpc_url,
            signers,
            agent_store,
            tx_type,
            pending_tx_timeout_secs,
            bundle_type,
            extra_msg_handles,
            redeploy,
            sync_nonces_after_batch,
            rpc_batch_size,
            gas_price,
        } = params;

        let (setcode_signer, _) = generate_setcode_signer(&rand_seed);
        debug!("setCode signer address: {}", setcode_signer.address());

        // use custom logging layer to log sendRawTransaction request IDs
        let client = ClientBuilder::default()
            .layer(LoggingLayer::new(prometheus.prom, prometheus.hist).await)
            .http(rpc_url.to_owned());
        let rpc_client = Arc::new(DynProvider::new(
            ProviderBuilder::new()
                .network::<AnyNetwork>()
                .connect_client(client),
        ));
        let genesis_block = rpc_client.get_block(BlockId::earliest()).await?;
        if genesis_block.is_none() {
            return Err(RuntimeErrorKind::GenesisBlockMissing.into());
        }
        let genesis_block = genesis_block.expect("genesis block");

        let mut wallet_map = HashMap::new();
        let mut signer_map = HashMap::new();
        let wallets = signers.iter().map(|s| {
            let w = EthereumWallet::new(s.clone());
            (s.address(), w)
        });
        for (addr, wallet) in wallets {
            wallet_map.insert(addr, wallet);
        }
        for s in &signers {
            signer_map.insert(s.address(), s.to_owned());
        }

        for (name, agent) in agent_store.all_agents() {
            debug!("adding '{name}' signers to wallet map");
            for signer in agent.signers.iter() {
                signer_map.insert(signer.address(), signer.clone());
            }
        }

        let mut nonces = HashMap::new();
        sync_nonces(
            &signer_map,
            &mut nonces,
            &rpc_client,
            setcode_signer.address(),
        )
        .await?;

        let gas_limits = HashMap::new();

        let bundle_client = if let Some(builder_url) = &builder_rpc_url {
            let client = ClientBuilder::default()
                .layer(LoggingLayer::new(prometheus.prom, prometheus.hist).await)
                .http(builder_url.to_owned());
            Some(Arc::new(BundleClient::from_client(client)))
        } else {
            None
        };

        let chain_id = rpc_client.get_chain_id().await?;
        let chain_id_builder = if let Some(builder_client) = &bundle_client {
            builder_client.get_chain_id().await?
        } else {
            chain_id
        };
        if chain_id != chain_id_builder {
            return Err(RuntimeErrorKind::ChainIdMismatch(chain_id, chain_id_builder).into());
        }

        let cancel_token = CancellationToken::new();

        // default msg_handle to handle txs sent on rpc_url
        let msg_handle = Arc::new(TxActorHandle::new(12000, db.clone(), rpc_client.clone()));
        let mut msg_handles = HashMap::new();
        msg_handles.insert("default".to_owned(), msg_handle);
        msg_handles.extend(extra_msg_handles.unwrap_or_default());
        let block_time_secs = get_block_time(rpc_client.as_ref()).await?;

        Ok(Self {
            config,
            db: db.clone(),
            rpc_url: rpc_url.to_owned(),
            rpc_client,
            bundle_client,
            builder_rpc_url,
            rand_seed: rand_seed.to_owned(),
            signer_map,
            agent_store,
            chain_id,
            nonces,
            gas_limits,
            msg_handles,
            tx_type,
            bundle_type,
            pending_tx_timeout_secs,
            ctx: ExecutionContext {
                gas_price_adder: 0,
                block_time_secs,
                cancel_token,
                chain_id,
                genesis_hash: genesis_block.header.hash,
            },
            auth_provider,
            prometheus,
            setcode_signer,
            redeploy,
            should_sync_nonces: sync_nonces_after_batch,
            rpc_batch_size,
            num_rpc_batches_sent: 0,
            gas_price,
        })
    }

    /// Fetch nonces for each account in `signer_map` from the RPC provider, assign the values to TestScenario's internal nonce map.
    pub async fn sync_nonces(&mut self) -> Result<()> {
        sync_nonces(
            &self.signer_map,
            &mut self.nonces,
            &self.rpc_client,
            self.setcode_signer.address(),
        )
        .await
    }

    pub fn tx_actor(&self) -> &TxActorHandle {
        self.msg_handles
            .get("default")
            .expect("default msg_handle uninitialized")
    }

    // Polls anvil to ensure its initialized and ready to accept RPC requests
    async fn wait_for_anvil_ready(endpoint_url: &Url, timeout: Duration) -> Result<()> {
        let start = std::time::Instant::now();

        loop {
            if start.elapsed() > timeout {
                return Err(RuntimeErrorKind::AnvilTimeout(timeout.as_secs()).into());
            }

            // Try a simple RPC call to check if Anvil is responsive
            let provider = ProviderBuilder::new()
                .network::<AnyNetwork>()
                .connect_http(endpoint_url.to_owned());

            match tokio::time::timeout(Duration::from_secs(2), provider.get_block_number()).await {
                Ok(Ok(_block_num)) => {
                    info!("anvil ready at {}", endpoint_url);
                    return Ok(());
                }
                Ok(Err(e)) => {
                    info!("anvil not ready yet (error: {}), retrying...", e);
                }
                Err(_) => {
                    info!("anvil health check timed out, retrying...");
                }
            }

            tokio::time::sleep(Duration::from_millis(500)).await;
        }
    }

    pub async fn estimate_setup_cost(&self) -> Result<U256> {
        println!("{}", SETUP_SIM_START);

        // use user-provided gas price or get gas price from chain to approximate gas cost
        let gas_price = match self.gas_price {
            Some(gas_price) => gas_price.to::<u128>(),
            None => self.rpc_client.get_gas_price().await?,
        };

        debug!(
            "reference gas price: {}gwei",
            format_units(gas_price, "gwei").unwrap()
        );

        // start anvil with dev accounts holding 1M eth
        let mut anvil = Anvil::new().args([
            "--balance",
            "1000000",
            "--gas-price",
            &(gas_price + GWEI_TO_WEI as u128 * 5).to_string(),
        ]);
        if !cfg!(test) {
            anvil = anvil
                .fork(self.rpc_url.to_string())
                .block_time_f64(1.0) // force anvil to produce a block every second
                .timeout(60000) // 60s timeout for fork operation
                ;
        }

        let anvil = anvil.try_spawn()?;
        Self::wait_for_anvil_ready(&anvil.endpoint_url(), Duration::from_secs(30)).await?;

        let admin_signer = LocalSigner::from_str(
            "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
        )
        .expect("invalid signer");

        // When override_senders is used, the agent_store might be empty but we still need
        // the original signers for the simulation to work correctly
        let simulation_signers = if self.agent_store.all_agents().count() == 0 {
            // If agent store is empty (override_senders case), use the original signers
            let mut signers = vec![admin_signer.to_owned()];
            signers.extend(self.signer_map.values().cloned());
            signers
        } else {
            vec![admin_signer.to_owned()]
        };

        // separate prometheus registry for simulations; anvil doesn't count!
        static PROM: OnceCell<prometheus::Registry> = OnceCell::const_new();
        static HIST: OnceCell<prometheus::HistogramVec> = OnceCell::const_new();
        let mut scenario = TestScenario::new(
            self.config.to_owned(),
            self.db.clone(),
            self.rand_seed.to_owned(),
            TestScenarioParams {
                rpc_url: anvil.endpoint_url(),
                builder_rpc_url: None,
                signers: simulation_signers,
                agent_store: self.agent_store.clone(),
                tx_type: self.tx_type,
                bundle_type: self.bundle_type,
                pending_tx_timeout_secs: self.pending_tx_timeout_secs,
                extra_msg_handles: None,
                redeploy: self.redeploy,
                sync_nonces_after_batch: self.should_sync_nonces,
                rpc_batch_size: self.rpc_batch_size,
                gas_price: self.gas_price,
            },
            None,
            (&PROM, &HIST).into(),
        )
        .await?;

        let addresses = scenario
            .agent_store
            .all_signer_addresses()
            .into_iter()
            .collect::<Vec<Address>>();

        let fund_amount = if addresses.len() >= 999 {
            U256::from(999999 * ETH_TO_WEI / addresses.len() as u128)
        } else {
            U256::from(1000 * ETH_TO_WEI)
        };

        let mut start_balances: HashMap<Address, U256> = HashMap::new();
        for addr in &addresses {
            let bal = scenario.rpc_client.get_balance(*addr).await.unwrap();
            start_balances.insert(*addr, bal + fund_amount);
        }

        for (_name, agent) in scenario.agent_store.all_agents() {
            agent
                .fund_signers(&admin_signer, fund_amount, scenario.rpc_client.clone())
                .await?;
        }

        debug!("deploying sim contracts...");
        scenario.deploy_contracts().await?;
        debug!("sim contracts deployed, running setup...");
        scenario.run_setup().await?;

        let mut total_cost = U256::ZERO;
        for (addr, start_balance) in &start_balances {
            let new_balance = scenario.rpc_client.get_balance(*addr).await?;
            if new_balance >= *start_balance {
                continue;
            }
            let cost = start_balance - new_balance;
            total_cost += cost;
        }

        println!("{}", SETUP_SIM_END);
        debug!("estimated setup cost: {}", format_ether(total_cost));

        // Shutdown the temporary simulation scenario to stop its actors
        scenario.shutdown().await;

        Ok(total_cost)
    }

    pub async fn deploy_contracts(&mut self) -> Result<()> {
        let pub_provider = &self.rpc_client;
        let gas_price = pub_provider.get_gas_price().await?;
        let blob_gas_price = get_blob_fee_maybe(&self.rpc_client).await;
        let chain_id = pub_provider.get_chain_id().await?;

        // we do everything in the callback so no need to actually capture the returned txs
        // we have to do this to populate the database with new named transaction after each deployment
        let redeploy = self.redeploy;
        let genesis_hash = self.ctx.genesis_hash;
        let (_txs, updated_nonces) = self
            .load_txs(PlanType::Create(|tx_req| {
                let from = tx_req.tx.from.to_owned().ok_or(
                    RuntimeErrorKind::NamedTxMissingFromAddress(Box::new(tx_req.to_owned())),
                )?;
                info!(
                    "deploying contract: {:?}",
                    tx_req.name.as_ref().unwrap_or(&"".to_string())
                );
                let rpc_url = self.rpc_url.to_owned();
                let tx_type = self.tx_type;
                let wallet = self
                    .signer_map
                    .get(&from)
                    .unwrap_or_else(|| panic!("couldn't find wallet for 'from' address {from}"))
                    .to_owned();
                let db = self.db.clone();

                let handle = tokio::task::spawn(async move {
                    Self::deploy_contract(DeployContractParams {
                        db: &db,
                        tx_req: &tx_req,
                        extra_tx_params: (gas_price, blob_gas_price, chain_id).into(),
                        tx_type,
                        rpc_url: &rpc_url,
                        signer: &wallet,
                        redeploy,
                        genesis_hash,
                    })
                    .await
                });

                Ok(Some(handle))
            }))
            .await?;

        // Update internal nonce map with the tracked nonces from load_txs.
        // This avoids relying on sync_nonces() which queries the RPC and may return
        // stale data if the RPC is slow to update after transactions are mined.
        self.nonces = updated_nonces;

        Ok(())
    }

    async fn deploy_contract<'a>(params: DeployContractParams<'a, D>) -> Result<()> {
        let DeployContractParams {
            db,
            tx_req,
            extra_tx_params,
            tx_type,
            rpc_url,
            signer,
            redeploy,
            genesis_hash,
        } = params;
        let wallet = EthereumWallet::from(signer.to_owned());
        let wallet_client = ProviderBuilder::new()
            .wallet(&wallet)
            .network::<AnyNetwork>()
            .connect_http(rpc_url.to_owned());

        if let Some(name) = tx_req.name.as_ref() {
            if let Some(existing) = db
                .get_named_tx(name, rpc_url.as_str(), genesis_hash)
                .map_err(|e| e.into())?
            {
                if let Some(addr) = existing.address {
                    let code: Bytes = wallet_client
                        .client()
                        .request("eth_getCode", (addr, "latest"))
                        .await?;
                    if !code.as_ref().is_empty() && !redeploy {
                        info!(
                            contract = %name,
                            address = %addr,
                            "skipping deploy; on-chain code already present"
                        );
                        return Ok(());
                    }
                }
            }
        }

        let ExtraTxParams {
            gas_price,
            blob_gas_price,
            chain_id,
        } = extra_tx_params;

        // estimate gas limit
        let gas_limit = wallet_client
            .estimate_gas(WithOtherFields::new(tx_req.tx.to_owned()))
            .await?;

        // inject missing fields into tx_req.tx
        let mut tx = tx_req.tx.to_owned();
        complete_tx_request(
            &mut tx,
            tx_type,
            gas_price,
            gas_price / 10,
            gas_limit,
            chain_id,
            blob_gas_price,
        );

        let res = wallet_client
            .send_transaction(WithOtherFields::new(tx))
            .await?
            .with_timeout(Some(Duration::from_secs(30)));

        // watch pending transaction
        let receipt = res.get_receipt().await.expect("failed to get receipt");
        debug!(
            "contract address: {}",
            receipt.contract_address.unwrap_or_default()
        );
        if let Some(name) = &tx_req.name {
            db.insert_named_txs(
                &[NamedTx::new(
                    name.to_owned(),
                    receipt.transaction_hash,
                    receipt.contract_address,
                )],
                rpc_url.as_str(),
                genesis_hash,
            )
            .map_err(|e| e.into())?;
        } else {
            warn!("No name provided for named transaction. This may cause issues with tracking the entry in the database.");
        }
        Ok(())
    }

    pub async fn run_setup(&mut self) -> Result<()> {
        let chain_id = self.chain_id;
        let genesis_hash = self.ctx.genesis_hash;
        let (_txs, updated_nonces) = self
            .load_txs(PlanType::Setup(|tx_req| {
                /* callback */
                info!("{}", self.format_setup_log(&tx_req));

                // copy data/refs from self before spawning the task
                let from =
                    tx_req
                        .tx
                        .from
                        .as_ref()
                        .ok_or(RuntimeErrorKind::NamedTxMissingFromAddress(Box::new(
                            tx_req.to_owned(),
                        )))?;
                let signer = self
                    .signer_map
                    .get(from)
                    .ok_or(RuntimeErrorKind::PrivateKeyMissing(*from))?
                    .to_owned();
                let db = self.db.clone();
                let rpc_url = self.rpc_url.clone();
                let tx_type = self.tx_type;

                let handle = tokio::task::spawn(async move {
                    let wallet = ProviderBuilder::new()
                        .wallet(signer)
                        .network::<AnyNetwork>()
                        .connect_http(rpc_url.to_owned());
                    debug!("connecting wallet to rpc at {}", rpc_url);

                    let tx_label = tx_req
                        .name
                        .as_deref()
                        .or(tx_req.kind.as_deref())
                        .unwrap_or("")
                        .to_string();
                    let gas_price = wallet.get_gas_price().await?;
                    let blob_gas_price =
                        get_blob_fee_maybe(&DynProvider::new(wallet.to_owned())).await;
                    let gas_limit = if let Some(gas) = tx_req.tx.gas {
                        gas
                    } else {
                        let res = wallet.estimate_gas(tx_req.tx.to_owned().into()).await;
                        if let Ok(res) = res {
                            res
                        } else {
                            warn!(
                            "failed to estimate gas for setup step '{tx_label}', skipping step..."
                        );
                            return Ok(());
                        }
                    };
                    let mut tx = tx_req.tx;
                    complete_tx_request(
                        &mut tx,
                        tx_type,
                        gas_price,
                        gas_price / 10,
                        gas_limit,
                        chain_id,
                        blob_gas_price,
                    );

                    // wallet will assign nonce before sending
                    let res = wallet
                        .send_transaction(tx.into())
                        .await?
                        .with_timeout(Some(Duration::from_secs(30)));

                    debug!("sent setup tx {:?}: {}", tx_req.kind, res.tx_hash());
                    // get receipt using provider (not wallet) to allow any receipt type (support non-eth chains)
                    let receipt = res.get_receipt().await?;
                    debug!(
                        "got receipt for {:?}: ({}) {}",
                        tx_req.kind,
                        if receipt.status() {
                            "LANDED"
                        } else {
                            "REVERTED"
                        },
                        receipt.transaction_hash
                    );

                    if let Some(name) = tx_req.name {
                        db.insert_named_txs(
                            &[NamedTx::new(
                                name,
                                receipt.transaction_hash,
                                receipt.contract_address,
                            )],
                            rpc_url.as_str(),
                            genesis_hash,
                        )
                        .map_err(|e| e.into())?;
                    }

                    Ok(())
                });
                Ok(Some(handle))
            }))
            .await?;

        // Update internal nonce map with the tracked nonces from load_txs.
        // This avoids relying on sync_nonces() which queries the RPC and may return
        // stale data if the RPC is slow to update after transactions are mined.
        self.nonces = updated_nonces;

        Ok(())
    }

    pub async fn prepare_tx_request(
        &mut self,
        tx_req: &TransactionRequest,
        gas_price: u128,
        blob_gas_price: u128,
    ) -> Result<(TransactionRequest, EthereumWallet)> {
        let from = tx_req
            .from
            .ok_or(RuntimeErrorKind::TxMissingFromAddress(Box::new(
                tx_req.to_owned(),
            )))?;
        let nonce = self
            .nonces
            .get(&from)
            .ok_or(RuntimeErrorKind::NonceMissing(from))?
            .to_owned();
        let setcode_signer_addr = self.setcode_signer.address();
        let setcode_signer_nonce = self
            .nonces
            .get(&setcode_signer_addr)
            .ok_or(RuntimeErrorKind::NonceMissing(from))?
            .to_owned();

        self.nonces.insert(from.to_owned(), nonce + 1);
        if tx_req.authorization_list.is_some() {
            self.nonces
                .insert(setcode_signer_addr, setcode_signer_nonce + 1);
        }

        self.update_gas_map(tx_req, blob_gas_price).await?;
        let gas_limit = self
            .gas_limits
            .get(&tx_req.key())
            .ok_or(RuntimeErrorKind::GasLimitMissingFromMap(Box::new(
                tx_req.to_owned(),
            )))?
            .to_owned();
        let signer = self
            .signer_map
            .get(&from)
            .ok_or(RuntimeErrorKind::SignerMissingFromMap(from))?
            .to_owned();

        let mut full_tx = tx_req.to_owned().with_nonce(nonce);
        complete_tx_request(
            &mut full_tx,
            self.tx_type,
            gas_price,
            gas_price / 10,
            gas_limit,
            self.chain_id,
            blob_gas_price,
        );

        Ok((full_tx, EthereumWallet::from(signer)))
    }

    pub async fn prepare_spam(
        &mut self,
        tx_requests: &[ExecutionRequest],
    ) -> Result<Vec<ExecutionPayload>> {
        let (gas_price, blob_gas_price) = match self.gas_price {
            Some(override_price) => (
                override_price.to::<u128>(),
                get_blob_fee_maybe(&self.rpc_client).await,
            ),
            None => {
                let gas_price = self.rpc_client.get_gas_price().await?;
                let blob_gas_price = get_blob_fee_maybe(&self.rpc_client).await;
                let adjusted_gas_price = |price: u128| {
                    if self.ctx.gas_price_adder < 0 {
                        price - self.ctx.gas_price_adder.unsigned_abs()
                    } else {
                        price + self.ctx.gas_price_adder as u128
                    }
                };

                (
                    adjusted_gas_price(gas_price),
                    adjusted_gas_price(blob_gas_price),
                )
            }
        };

        let mut payloads = vec![];
        info!("preparing {} spam payloads", tx_requests.len());

        for tx in tx_requests {
            let payload = match tx {
                ExecutionRequest::Bundle(reqs) => {
                    // prepare each tx in the bundle (increment nonce, set gas price, etc)
                    let mut bundle_txs = vec![];
                    if self.bundle_client.is_none() {
                        return Err(RuntimeErrorKind::InvalidParams(
                            RuntimeParamErrorKind::BuilderUrlRequired,
                        )
                        .into());
                    }

                    for req in reqs {
                        let (tx_req, signer) = self
                            .prepare_tx_request(&req.tx, gas_price, blob_gas_price)
                            .await?;

                        trace!("bundle tx: {tx_req:?}");
                        // sign tx
                        let tx_envelope = tx_req.build(&signer).await?;

                        bundle_txs.push(tx_envelope);
                    }
                    ExecutionPayload::SignedTxBundle(bundle_txs, reqs.to_owned())
                }
                ExecutionRequest::Tx(req) => {
                    let (tx_req, signer) = self
                        .prepare_tx_request(&req.tx, gas_price, blob_gas_price)
                        .await?;
                    let mut new_req = req.to_owned();
                    new_req.tx = tx_req.to_owned();

                    // sign tx
                    let tx_envelope = tx_req.build(&signer).await?;

                    // log tx details
                    let priority_fee = new_req
                        .tx
                        .max_priority_fee_per_gas
                        .map(|f| format!(" priority_fee: {f},"))
                        .unwrap_or_default();
                    debug!(
                        "prepared tx: {}, from: {}, to: {:?}, input: {}, value={}, gas_limit: {}, gas_price: {},{priority_fee} nonce={}",
                        tx_envelope.tx_hash(),
                        new_req.tx.from.map(|s| s.encode_hex()).unwrap_or_default(),
                        tx_envelope.to(),
                        new_req.tx
                            .input
                            .input
                            .as_ref()
                            .map(|s| s.encode_hex())
                            .unwrap_or_default(),
                        new_req.tx
                            .value
                            .map(|s| s.to_string())
                            .unwrap_or("0".to_owned()),
                        new_req.tx
                            .gas
                            .map(|g| g.to_string())
                            .unwrap_or("N/A".to_owned()),
                        new_req.tx.gas_price.unwrap_or(new_req.tx.max_fee_per_gas.unwrap_or(0)),
                        new_req.tx.nonce.map(|n| n.to_string()).unwrap_or("N/A".to_owned())
                    );

                    ExecutionPayload::SignedTx(Box::new(tx_envelope), new_req)
                }
            };
            payloads.push(payload);
        }
        info!("prepared {} payloads", payloads.len());
        Ok(payloads)
    }

    /// Send one batch of spam txs evenly over one second.
    async fn execute_spam<F: SpamCallback + 'static>(
        &mut self,
        trigger: SpamTrigger,
        payloads: Vec<ExecutionPayload>,
        callback_handler: Arc<F>,
        context_handler: SpamContextHandler,
    ) -> Result<(
        Vec<tokio::task::JoinHandle<()>>,
        tokio::sync::mpsc::Receiver<Error>,
    )> {
        // sort payloads by nonce
        let mut payloads = payloads;
        payloads.sort_by(|a, b| {
            let a_nonce = match a {
                ExecutionPayload::SignedTx(_, req) => req.tx.nonce,
                ExecutionPayload::SignedTxBundle(_, reqs) => reqs[0].tx.nonce,
            };
            let b_nonce = match b {
                ExecutionPayload::SignedTx(_, req) => req.tx.nonce,
                ExecutionPayload::SignedTxBundle(_, reqs) => reqs[0].tx.nonce,
            };
            a_nonce.cmp(&b_nonce)
        });

        let num_payloads = payloads.len();

        let mut tasks: Vec<tokio::task::JoinHandle<()>> = vec![];

        // takes gas to add to the gas price for the next batch (if needed)
        let gas_sender = Arc::new(context_handler.add_gas);
        // shifts nonce of address by given amount
        let nonce_sender = Arc::new(context_handler.shift_nonce);
        // counts number of txs that were sent successfully
        let success_sender = Arc::new(context_handler.success_send_tx);
        let bundle_type = self.bundle_type;
        let (error_sender, error_receiver) = tokio::sync::mpsc::channel::<Error>(1);
        let error_sender = Arc::new(error_sender);

        // Should use json-rpc batching for this tick if both conditions are met:
        //  - rpc_batch_size > 0
        //  - all payloads are SignedTx (no builder bundles)
        let should_batch_rpc = self.rpc_batch_size > 0
            && payloads
                .iter()
                .all(|p| matches!(p, ExecutionPayload::SignedTx(_, _)));

        if !should_batch_rpc {
            let micros_per_task = 1_000_000 / num_payloads.max(1) as u64;

            for payload in payloads {
                self.num_rpc_batches_sent += 1;
                let rpc_client = self.rpc_client.clone();
                let bundle_client = self.bundle_client.clone();
                let tx_handlers = self.msg_handles.clone();
                let callback_handler = callback_handler.clone();
                let gas_sender = gas_sender.clone();
                let success_sender = success_sender.clone();
                let nonce_sender = nonce_sender.clone();
                let cancel_token = self.ctx.cancel_token.clone();
                let error_sender = error_sender.clone();

                // Wait to space transactions out evenly across a second
                tokio::time::sleep(Duration::from_micros(micros_per_task)).await;
                tasks.push(tokio::task::spawn(async move {
                let extra = RuntimeTxInfo::default();
                let handles = match payload {
                    ExecutionPayload::SignedTx(signed_tx, req) => {
                        let tx_hash = signed_tx.tx_hash().to_owned();
                        let res = rpc_client
                            .send_tx_envelope(AnyTxEnvelope::Ethereum(*signed_tx))
                            .await;
                        let ctx = SpamRunContext {
                            nonce_sender: &nonce_sender,
                            success_sender: &success_sender,
                            gas_sender: &gas_sender,
                            callback_handler: callback_handler.as_ref(),
                            tx_handlers: &tx_handlers,
                            cancel_token: &cancel_token,
                        };

                        match res {
                            Ok(_) => {
                                // no error message
                                handle_tx_outcome(
                                    tx_hash,
                                    &req,
                                    extra,
                                    None,
                                    &ctx
                                )
                                .await;
                                Vec::<Option<tokio::task::JoinHandle<_>>>::new()
                            }
                            Err(e) => {
                                let msg_string = e
                                    .as_error_resp()
                                    .map(|err| err.message.to_string())
                                    .unwrap_or_else(|| "send_tx_envelope failed".to_string());
                                handle_tx_outcome(
                                    tx_hash,
                                    &req,
                                    extra,
                                    Some(msg_string.as_str()),
                                    &ctx
                                )
                                .await;
                                Vec::<Option<tokio::task::JoinHandle<_>>>::new()
                            }
                        }
                    }
                    ExecutionPayload::SignedTxBundle(signed_txs, reqs) => {
                        let mut bundle_txs = vec![];
                        for tx in &signed_txs {
                            let mut raw_tx = vec![];
                            tx.encode_2718(&mut raw_tx);
                            bundle_txs.push(Bytes::from(raw_tx));
                        }
                        let block_num = match trigger {
                            SpamTrigger::BlockNumber(n) => n,
                            SpamTrigger::BlockHash(h) => {
                                let block = rpc_client
                                    .get_block_by_hash(h)
                                    .await
                                    .expect("failed to get block by hash")
                                    .expect("block not found");
                                block.header.number
                            }
                            _ => rpc_client
                                .get_block_number()
                                .await
                                .expect("failed to get block number"),
                        };

                        let rpc_bundle = match bundle_type {
                            BundleType::L1 => new_basic_bundle(bundle_txs, block_num + 1),
                            BundleType::RevertProtected => RevertProtectBundleRequest::new()
                                .with_txs(bundle_txs)
                                .prepare(),
                        };
                        let success_sender = success_sender.clone();
                        let bundle_client = bundle_client
                            .expect("test_scenario must be initialized with a bundle client to send bundles");
                        info!("sending bundle...");
                        debug!("bundle: {rpc_bundle:?}");

                        let res = rpc_bundle.send(&bundle_client).await.map_err(|e| e.into());
                        if let Err(e) = res {
                            error_sender
                                .send(e)
                                .await
                                .unwrap_or_else(|e| trace!("failed to send error signal: {e:?}"));
                        } else {
                            success_sender
                                .send(())
                                .await
                                .unwrap_or_else(|e| trace!("failed to send success signal: {e:?}"));
                        }

                        let mut tx_handles = vec![];
                        for (tx, req) in signed_txs.into_iter().zip(reqs) {
                            let maybe_handle = callback_handler.on_tx_sent(
                                PendingTransactionConfig::new(*tx.tx_hash()),
                                &req,
                                extra.clone(),
                                Some(tx_handlers.clone()),
                            );
                            tx_handles.push(maybe_handle);
                        }
                        tx_handles
                    }
                };

                // Handle bundle tx callbacks
                for handle in handles.into_iter().flatten() {
                    tokio::select! {
                        _ = cancel_token.cancelled() => {
                            debug!("cancelled spammer task");
                            return;
                        }
                        _ = handle => {
                            // wait for the task to finish
                        }
                    }
                }
            }));
            }

            return Ok((tasks, error_receiver));
        }

        // === json-rpc batch mode for SignedTx payloads ===
        let batch_size = self.rpc_batch_size as usize;
        let num_batches = num_payloads.div_ceil(batch_size).max(1) as u64;
        let micros_per_batch = 1_000_000 / num_batches;

        let rpc_url = self.rpc_url.clone();
        let http_client = reqwest::Client::new();

        info!(
            "using json-rpc batching with batch size {}",
            self.rpc_batch_size
        );

        for chunk in payloads.chunks(batch_size) {
            self.num_rpc_batches_sent += 1;
            let tx_handlers = self.msg_handles.clone();
            let callback_handler = callback_handler.clone();
            let gas_sender = gas_sender.clone();
            let nonce_sender = nonce_sender.clone();
            let success_sender = success_sender.clone();
            let cancel_token = self.ctx.cancel_token.clone();
            let http_client = http_client.clone();
            let rpc_url = rpc_url.clone();

            let signed_chunk: Vec<_> = chunk
                .iter()
                .map(|p| {
                    if let ExecutionPayload::SignedTx(signed_tx, req) = p {
                        (signed_tx.clone(), req.as_ref().clone())
                    } else {
                        unreachable!("can_batch_rpc guarantees only SignedTx here");
                    }
                })
                .collect();

            tokio::time::sleep(Duration::from_micros(micros_per_batch)).await;
            tasks.push(tokio::task::spawn(async move {
                // Build json-rpc batch payload with multiple eth_sendRawTransaction requests
                let mut requests = Vec::with_capacity(signed_chunk.len());
                for (i, (signed_tx, _)) in signed_chunk.iter().enumerate() {
                    let mut raw_tx = Vec::new();
                    signed_tx.encode_2718(&mut raw_tx);
                    let raw_hex = format!("0x{}", raw_tx.encode_hex());
                    requests.push(json!({
                        "jsonrpc": "2.0",
                        "id": i as u64,
                        "method": "eth_sendRawTransaction",
                        "params": [raw_hex],
                    }));
                }

                let resp = match http_client.post(rpc_url).json(&requests).send().await {
                    Ok(r) => r,
                    Err(e) => {
                        warn!("failed to send JSON-RPC batch: {e:?}");
                        return;
                    }
                };

                let responses: Vec<serde_json::Value> = match resp.json().await {
                    Ok(v) => v,
                    Err(e) => {
                        warn!("failed to parse JSON-RPC batch response: {e:?}");
                        return;
                    }
                };

                // Process each response; align by index with signed_chunk
                for (i, (signed_tx, req)) in signed_chunk.into_iter().enumerate() {
                    let tx_hash = *signed_tx.tx_hash();
                    let extra = RuntimeTxInfo::default();

                    let error_msg = responses
                        .get(i)
                        .and_then(|resp| resp.get("error"))
                        .and_then(|e| e.get("message"))
                        .and_then(|m| m.as_str());

                    let ctx = SpamRunContext {
                        nonce_sender: &nonce_sender,
                        success_sender: &success_sender,
                        gas_sender: &gas_sender,
                        callback_handler: callback_handler.as_ref(),
                        tx_handlers: &tx_handlers,
                        cancel_token: &cancel_token,
                    };
                    handle_tx_outcome(tx_hash, &req, extra, error_msg, &ctx).await;
                }
            }));
        }

        Ok((tasks, error_receiver))
    }

    /// Send spam batches until the cursor is depleted.
    pub async fn execute_spammer<F: SpamCallback + 'static>(
        &mut self,
        cursor: &mut futures::stream::Take<Pin<Box<dyn Stream<Item = SpamTrigger> + Send>>>,
        tx_req_chunks: &[Vec<ExecutionRequest>],
        sent_tx_callback: Arc<F>,
    ) -> Result<()> {
        let mut tick = 0;
        while let Some(trigger) = cursor.next().await {
            let trigger = trigger.to_owned();
            // assign from addrs, nonces, and gas prices for this chunk of tx requests
            let payloads = self
                .prepare_spam(&tx_req_chunks[tick % tx_req_chunks.len().max(1)])
                .await?;
            let num_payloads = payloads.len();

            // initialize async context handlers
            let (success_sender, mut success_receiver) = tokio::sync::mpsc::channel(num_payloads);
            let (add_gas_sender, mut add_gas_receiver) = tokio::sync::mpsc::channel(num_payloads);
            let (shift_nonce_sender, mut shift_nonce_receiver) =
                tokio::sync::mpsc::channel(tx_req_chunks[0].len());
            let context = SpamContextHandler {
                success_send_tx: success_sender,
                add_gas: add_gas_sender,
                shift_nonce: shift_nonce_sender,
            };

            // send this batch of spam txs
            let (spam_tasks, mut error_receiver) = self
                .execute_spam(trigger, payloads, sent_tx_callback.clone(), context)
                .await?;
            let mut num_tasks = spam_tasks.len();

            // wait for spam txs to finish sending
            for task in spam_tasks {
                tokio::select! {
                    res = task => {
                        if let Err(e) = res {
                            tracing::trace!("spam task abandoned: {e:?}");
                            num_tasks -= 1;
                        }
                    },
                    Some(err) = error_receiver.recv() => {
                        return Err(err);
                    }
                    _ = self.ctx.cancel_token.cancelled() => {
                        break;
                    }
                }
            }

            // wait for the on_batch_sent callback to finish
            if let Some(task) = sent_tx_callback.on_batch_sent() {
                task.await.map_err(CallbackError::Join)??;
            }

            info!("[{tick}] executed {num_tasks} spam tasks");

            // increase gas price if needed
            add_gas_receiver.close();
            let starting_gas_adder = self.ctx.gas_price_adder;
            while let Some(gas) = add_gas_receiver.recv().await {
                if self.ctx.gas_price_adder >= gas as i128 + starting_gas_adder {
                    continue;
                }
                debug!("incrementing gas price by {gas}");
                self.ctx.add_to_gas_price(gas as i128);
            }

            // shift nonces if needed
            // Accumulate all nonce adjustments per address to avoid race conditions
            // where multiple updates for the same address read stale nonce values
            shift_nonce_receiver.close();
            let mut nonce_adjustments: HashMap<Address, i32> = HashMap::new();
            while let Some((addr, shift)) = shift_nonce_receiver.recv().await {
                *nonce_adjustments.entry(addr).or_insert(0) += shift;
            }

            // Apply accumulated adjustments
            for (addr, total_shift) in nonce_adjustments {
                let current_nonce = self.nonces.get(&addr).copied().unwrap_or_default();
                let new_nonce = if total_shift < 0 {
                    current_nonce.saturating_sub(total_shift.unsigned_abs() as u64)
                } else {
                    current_nonce.saturating_add(total_shift as u64)
                };
                debug!(
                    "nonce for {} adjusted by {} (from {} to {})",
                    addr, total_shift, current_nonce, new_nonce
                );
                self.nonces.insert(addr, new_nonce);
            }

            // decrease gas price if all txs were sent successfully
            success_receiver.close();
            let mut success_count = 0;
            while success_receiver.recv().await.is_some() {
                success_count += 1;
            }
            if success_count == num_payloads {
                info!("all spam txs sent successfully");
                if self.ctx.gas_price_adder > 0 {
                    // remove 10% of the gas price adder
                    self.ctx.add_to_gas_price(self.ctx.gas_price_adder / -10);
                }
            } else {
                warn!(
                    "some spam txs failed to send: {} / {}",
                    num_payloads - success_count,
                    num_payloads
                );
            }

            // increment tick to get next chunk of txs
            tick += 1;
        }

        Ok(())
    }

    fn format_setup_log(&self, tx_req: &NamedTxRequest) -> String {
        let to_address = tx_req.tx.to.unwrap_or_default();
        let to_address = to_address.to();

        // lookup name of contract if it exists
        let to_name = to_address.map(|a| {
            let named_tx = self.db.get_named_tx_by_address(a);
            named_tx
                .map(|t| t.map(|tt| tt.name).unwrap_or_default())
                .unwrap_or_default()
        });

        format!(
            "running setup: from={} to={} gas={:?} {}",
            tx_req
                .tx
                .from
                .as_ref()
                .map(|a| a.encode_hex())
                .unwrap_or_default(),
            if let Some(to) = to_name {
                to
            } else {
                to_address.map(|a| a.encode_hex()).unwrap_or_default()
            },
            tx_req.tx.gas,
            if let Some(kind) = &tx_req.kind {
                format!("kind={kind}")
            } else {
                "".to_string()
            },
        )
    }

    /// Returns the maximum cost of a single spam transaction by creating a new scenario
    /// and running estimateGas calls to estimate the cost of the spam transactions.
    pub async fn get_max_spam_cost(&self, user_signers: &[PrivateKeySigner]) -> Result<U256> {
        // separate prometheus registry for simulations; anvil doesn't count!
        static PROM: OnceCell<prometheus::Registry> = OnceCell::const_new();
        static HIST: OnceCell<prometheus::HistogramVec> = OnceCell::const_new();
        let mut scenario = TestScenario::new(
            self.config.to_owned(),
            self.db.clone(),
            self.rand_seed.clone(),
            TestScenarioParams {
                rpc_url: self.rpc_url.clone(),
                builder_rpc_url: self.builder_rpc_url.clone(),
                signers: user_signers.to_owned(),
                agent_store: self.agent_store.clone(),
                tx_type: self.tx_type,
                bundle_type: self.bundle_type,
                pending_tx_timeout_secs: self.pending_tx_timeout_secs,
                extra_msg_handles: None,
                redeploy: false,
                sync_nonces_after_batch: self.should_sync_nonces,
                rpc_batch_size: self.rpc_batch_size,
                gas_price: self.gas_price,
            },
            None,
            (&PROM, &HIST).into(),
        )
        .await?;

        // load a sample of each spam tx from the scenario
        let (txs, _nonces) = scenario
            .load_txs(PlanType::Spam(
                scenario
                    .config
                    .get_spam_steps()
                    .map(|s| s.len()) // take the number of spam txs from the testfile
                    .unwrap_or(0) as u64,
                |_named_req| {
                    // we can look at the named request here if needed
                    Ok(None)
                },
            ))
            .await?;
        let sample_txs = scenario
            .prepare_spam(&txs)
            .await?
            .iter()
            .map(|ex_payload| match ex_payload {
                ExecutionPayload::SignedTx(_envelope, tx_req) => vec![tx_req.to_owned()],
                ExecutionPayload::SignedTxBundle(_envelopes, tx_reqs) => tx_reqs
                    .iter()
                    .map(|tx| Box::new(tx.to_owned()))
                    .collect::<Vec<_>>(),
            })
            .collect::<Vec<_>>()
            .concat();

        let (gas_price, blob_gas_price) = match scenario.gas_price {
            Some(override_price) => (
                override_price.to::<u128>(),
                get_blob_fee_maybe(&scenario.rpc_client).await,
            ),
            None => (
                scenario.rpc_client.get_gas_price().await?,
                get_blob_fee_maybe(&scenario.rpc_client).await,
            ),
        };

        // get gas limit for each tx
        let mut prepared_sample_txs = vec![];
        for tx in sample_txs {
            let tx_req = tx.tx;
            let (prepared_req, _signer) = scenario
                .prepare_tx_request(&tx_req, gas_price, blob_gas_price)
                .await?;
            prepared_sample_txs.push(prepared_req);
        }

        // get the highest gas cost of all spam txs
        let highest_gas_cost = prepared_sample_txs
            .iter()
            .map(|tx| {
                let mut gas_price = tx.max_fee_per_gas.unwrap_or(tx.gas_price.unwrap_or(0));
                if let Some(priority_fee) = tx.max_priority_fee_per_gas {
                    gas_price += priority_fee;
                }
                U256::from(gas_price * tx.gas.unwrap_or(0) as u128) + tx.value.unwrap_or(U256::ZERO)
            })
            .max()
            .ok_or(RuntimeErrorKind::SpamTxsEmpty)?;

        // Shutdown the temporary scenario to stop its actors
        scenario.shutdown().await;

        // we assume the highest possible cost to minimize the chances of running out of ETH mid-test
        Ok(highest_gas_cost)
    }

    pub async fn get_spam_tx_chunks(
        &self,
        txs_per_period: u64,
        num_periods: u64,
    ) -> Result<Vec<Vec<ExecutionRequest>>> {
        let (tx_requests, _nonces) = self
            .load_txs(crate::generator::PlanType::Spam(
                txs_per_period * num_periods,
                |_named_req| Ok(None), // we can look at the named request here if needed
            ))
            .await?;
        Ok(tx_requests
            .chunks(txs_per_period as usize)
            .map(|chunk| chunk.to_vec())
            .collect::<_>())
    }

    /// Wait for `self.pending_tx_timeout_secs` for pending txs to confirm, then delete any remaining cache items.
    pub async fn dump_tx_cache(&self, run_id: u64) -> Result<()> {
        debug!("dumping tx cache...");

        let start_time = Instant::now();
        for msg_handle in self.msg_handles.values() {
            tokio::select! {
                _ = self.ctx.cancel_token.cancelled() => {
                }
                _ = async {
                    while !self.tx_actor().done_flushing().await? {
                        if start_time.elapsed().as_secs() > self.pending_tx_timeout_secs {
                            warn!("timed out waiting for pending transactions");
                            break;
                        }
                    }
                    msg_handle.dump_cache(run_id).await?;
                    Ok::<_, Error>(())
                } => {}
            }
        }

        Ok(())
    }

    /// Collects latency metrics from the prometheus registry.
    /// Returns a map of RPC method names to a vector of latency buckets which represent (upper_bound_secs, cumulative_count).
    pub fn collect_latency_metrics(&self) -> BTreeMap<String, Vec<Bucket>> {
        let registry = self.prometheus.prom.get();
        let mut latency_map = BTreeMap::new();
        if let Some(registry) = registry {
            let metric_families = registry.gather();

            for mf in &metric_families {
                if mf.name() == RPC_REQUEST_LATENCY_ID {
                    for m in mf.get_metric() {
                        let mut latencies: Vec<Bucket> = vec![];
                        if m.label.is_empty() {
                            continue;
                        }
                        let label = m.label.first().expect("label");
                        if label.name() != "rpc_method" {
                            continue;
                        }
                        let hist = m.get_histogram();
                        for bucket in &hist.bucket {
                            if bucket.cumulative_count.is_none() {
                                continue;
                            }
                            let upper_bound = bucket.upper_bound();
                            let cumulative_count =
                                bucket.cumulative_count.expect("cumulative_count");

                            latencies.push((upper_bound, cumulative_count).into());
                        }
                        latency_map.insert(label.value().to_string(), latencies);
                    }
                }
            }
        }
        latency_map
    }

    /// Updates gas limits hashmap for a given tx, returns the key used to index the tx to its gas limit.
    async fn update_gas_map(
        &mut self,
        tx_req: &TransactionRequest,
        blob_gas_price: u128,
    ) -> Result<FixedBytes<32>> {
        let key = tx_req.key();
        if let std::collections::hash_map::Entry::Vacant(_) = self.gas_limits.entry(key) {
            let mut tx_req = tx_req.to_owned();
            if let Some(sidecar) = &tx_req.sidecar {
                tx_req.max_fee_per_blob_gas = Some(blob_gas_price);
                tx_req.blob_versioned_hashes = Some(sidecar.versioned_hashes().collect());
            }
            let gas_limit = if let Some(gas) = tx_req.gas {
                gas
            } else {
                if let Some(TxKind::Call(address)) = &tx_req.to {
                    let data = tx_req.input.input.to_owned().unwrap_or_default();
                    if !data.is_empty() {
                        // assume that with calldata, we're trying to call a contract, so it should have code
                        let code = self.rpc_client.get_code_at(*address).await?;
                        if code.is_empty() {
                            warn!("Trying to call an address with no code... If you're targeting a smart contract, you may need to run contender setup to re-deploy it.");
                        }
                    }
                }
                self.rpc_client
                    .estimate_gas(WithOtherFields::new(tx_req.to_owned()))
                    .await?
            };
            self.gas_limits.insert(key, gas_limit);
        }
        Ok(key)
    }

    pub async fn shutdown(&mut self) {
        self.ctx.cancel_token.cancel();
        // Stop all actors
        for (name, handle) in &self.msg_handles {
            if let Err(e) = handle.stop().await {
                debug!("Error stopping actor '{}': {:?}", name, e);
            }
        }
    }

    pub async fn is_shutdown(&self) -> bool {
        self.ctx.cancel_token.is_cancelled()
    }
}

async fn handle_tx_outcome<'a, F: SpamCallback + 'static>(
    tx_hash: alloy::primitives::TxHash,
    req: &NamedTxRequest,
    mut extra: RuntimeTxInfo,
    error_msg: Option<&str>,
    ctx: &SpamRunContext<'a, F>,
) {
    // gas bump if needed
    if let Some(msg) = error_msg {
        let message = msg.to_lowercase();
        if message.contains("replacement transaction underpriced") {
            let bump = req
                .tx
                .max_fee_per_gas
                .unwrap_or(req.tx.gas_price.unwrap_or(1_000_000_000))
                / 10;
            if let Err(e) = ctx.gas_sender.send(bump).await {
                warn!("failed to send gas bump for tx {}: {:?}", tx_hash, e);
            }
        } else if message.contains("nonce too low") {
            if let Some(from) = req.tx.from {
                debug!("incrementing nonce for {}", from);
                if let Err(e) = ctx.nonce_sender.send((from, 1)).await {
                    warn!("failed to send nonce increment for {}: {:?}", from, e);
                }
            } else {
                warn!(
                    "nonce too low error but tx.from is missing for tx {}",
                    tx_hash
                );
            }
        } else if message.contains("nonce too high") {
            if let Some(from) = req.tx.from {
                debug!("decrementing nonce for {}", from);
                if let Err(e) = ctx.nonce_sender.send((from, -1)).await {
                    warn!("failed to send nonce decrement for {}: {:?}", from, e);
                }
            } else {
                warn!(
                    "nonce too high error but tx.from is missing for tx {}",
                    tx_hash
                );
            }
        }
        if !(msg.contains("nonce too low")
            || msg.contains("replacement transaction underpriced")
            || msg.contains("transaction already imported"))
        {
            warn!("error from tx {tx_hash}: {msg}");
        }
        debug!("error from tx ${tx_hash}: {msg}");
        extra = extra.with_error(msg.to_string());
    } else {
        // success path
        if let Err(e) = ctx.success_sender.send(()).await {
            // this error can safely be ignored; it just means the receiver was closed (e.g. by CTRL-C)
            debug!(
                "failed to send success notification for tx {}: {:?}",
                tx_hash, e
            );
        }
    }

    // Fire-and-forget - the callback task runs concurrently and has its own cancel token handling
    let _ = ctx.callback_handler.on_tx_sent(
        PendingTransactionConfig::new(tx_hash),
        req,
        extra,
        Some(ctx.tx_handlers.clone()),
    );
}

async fn sync_nonces(
    wallet_map: &HashMap<Address, PrivateKeySigner>,
    nonces: &mut HashMap<Address, u64>,
    rpc_client: &AnyProvider,
    setcode_signer_address: Address,
) -> Result<()> {
    let mut all_addrs = wallet_map.keys().copied().collect::<Vec<Address>>();
    all_addrs.push(setcode_signer_address);
    let mut tasks = vec![];
    let (sender, mut receiver) = tokio::sync::mpsc::channel::<(Address, u64)>(all_addrs.len() + 1);
    for addr in all_addrs {
        let send = sender.clone();
        let rpc_client = Arc::new(rpc_client.clone());
        tasks.push(tokio::task::spawn(async move {
            let nonce = rpc_client.get_transaction_count(addr).await?;
            send.send((addr, nonce))
                .await
                .map_err(CallbackError::MpscSendAddrNonce)?;
            Ok::<_, Error>(())
        }));
    }

    for task in tasks {
        if let Err(e) = task.await {
            warn!("failed to sync nonce: {e:?}");
        }
    }
    receiver.close();

    debug!("waiting for nonces to sync...");
    while let Some((addr, nonce)) = receiver.recv().await {
        nonces.insert(addr, nonce);
    }

    Ok(())
}

impl<D, S, P> Generator<String, D, P> for TestScenario<D, S, P>
where
    D: DbOps + Send + Sync,
    S: Seeder,
    P: PlanConfig<String> + Templater<String> + Send + Sync,
{
    fn get_db(&self) -> &D {
        self.db.as_ref()
    }

    fn get_templater(&self) -> &P {
        &self.config
    }

    fn get_plan_conf(&self) -> &impl PlanConfig<String> {
        &self.config
    }

    fn get_fuzz_seeder(&self) -> &impl Seeder {
        &self.rand_seed
    }

    fn get_agent_store(&self) -> &AgentStore {
        &self.agent_store
    }

    fn get_rpc_url(&self) -> String {
        self.rpc_url.to_string()
    }

    fn get_chain_id(&self) -> u64 {
        self.ctx.chain_id
    }

    fn get_rpc_provider(&self) -> &AnyProvider {
        &self.rpc_client
    }

    fn get_nonce_map(&self) -> &HashMap<Address, u64> {
        &self.nonces
    }

    fn get_setcode_signer(&self) -> &PrivateKeySigner {
        &self.setcode_signer
    }

    fn get_genesis_hash(&self) -> FixedBytes<32> {
        self.ctx.genesis_hash
    }
}

struct SpamContextHandler {
    add_gas: tokio::sync::mpsc::Sender<u128>,
    success_send_tx: tokio::sync::mpsc::Sender<()>,
    shift_nonce: tokio::sync::mpsc::Sender<(Address, i32)>,
}

trait TxKey {
    /// Defines a key to index a unique transaction request (e.g. in a hashmap).
    fn key(&self) -> FixedBytes<32>;
}

impl TxKey for TransactionRequest {
    fn key(&self) -> FixedBytes<32> {
        keccak256(self.input.input.to_owned().unwrap_or_default())
    }
}

#[cfg(test)]
pub mod tests {
    use crate::agent_controller::AgentStore;
    use crate::db::MockDb;
    use crate::error::RuntimeErrorKind;
    use crate::generator::error::GeneratorError;
    use crate::generator::named_txs::ExecutionRequest;
    use crate::generator::templater::Templater;
    use crate::generator::types::SpamRequest;
    use crate::generator::{types::PlanType, util::test::spawn_anvil, RandSeed};
    use crate::generator::{
        CompiledContract, CreateDefinition, FunctionCallDefinition, FuzzParam, Generator,
        PlanConfig,
    };
    use crate::spammer::util::test::get_test_signers;
    use crate::spammer::{BlockwiseSpammer, NilCallback, Spammer};
    use crate::test_scenario::TestScenario;
    use crate::Error;
    use crate::Result;
    use alloy::consensus::constants::GWEI_TO_WEI;
    use alloy::hex::ToHexExt;
    use alloy::node_bindings::{Anvil, AnvilInstance};
    use alloy::primitives::utils::format_ether;
    use alloy::primitives::{Address, U256};
    use alloy::providers::Provider;
    use contender_bundle_provider::bundle::BundleType;
    use std::collections::HashMap;
    use std::sync::Arc;
    use tokio::sync::OnceCell;

    use super::TestScenarioParams;

    // separate prometheus registry for simulations; anvil doesn't count!
    static PROM: OnceCell<prometheus::Registry> = OnceCell::const_new();
    static HIST: OnceCell<prometheus::HistogramVec> = OnceCell::const_new();

    #[derive(Clone)]
    pub struct MockConfig;

    pub const COUNTER_BYTECODE: &str =
        "0x608060405234801561001057600080fd5b5060f78061001f6000396000f3fe6080604052348015600f57600080fd5b5060043610603c5760003560e01c80633fb5c1cb1460415780638381f58a146053578063d09de08a14606d575b600080fd5b6051604c3660046083565b600055565b005b605b60005481565b60405190815260200160405180910390f35b6051600080549080607c83609b565b9190505550565b600060208284031215609457600080fd5b5035919050565b60006001820160ba57634e487b7160e01b600052601160045260246000fd5b506001019056fea264697066735822122010f3077836fb83a22ad708a23102f2b487523767e1afef5a93c614619001648b64736f6c63430008170033";
    pub const UNI_V2_FACTORY_BYTECODE: &str = "0x608060405234801561001057600080fd5b506040516136863803806136868339818101604052602081101561003357600080fd5b5051600180546001600160a01b0319166001600160a01b03909216919091179055613623806100636000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063a2e74af61161005b578063a2e74af6146100fd578063c9c6539614610132578063e6a439051461016d578063f46901ed146101a857610088565b8063017e7e581461008d578063094b7415146100be5780631e3dd18b146100c6578063574f2ba3146100e3575b600080fd5b6100956101db565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b6100956101f7565b610095600480360360208110156100dc57600080fd5b5035610213565b6100eb610247565b60408051918252519081900360200190f35b6101306004803603602081101561011357600080fd5b503573ffffffffffffffffffffffffffffffffffffffff1661024d565b005b6100956004803603604081101561014857600080fd5b5073ffffffffffffffffffffffffffffffffffffffff8135811691602001351661031a565b6100956004803603604081101561018357600080fd5b5073ffffffffffffffffffffffffffffffffffffffff8135811691602001351661076d565b610130600480360360208110156101be57600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166107a0565b60005473ffffffffffffffffffffffffffffffffffffffff1681565b60015473ffffffffffffffffffffffffffffffffffffffff1681565b6003818154811061022057fe5b60009182526020909120015473ffffffffffffffffffffffffffffffffffffffff16905081565b60035490565b60015473ffffffffffffffffffffffffffffffffffffffff1633146102d357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f556e697377617056323a20464f5242494444454e000000000000000000000000604482015290519081900360640190fd5b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60008173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156103b757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f556e697377617056323a204944454e544943414c5f4144445245535345530000604482015290519081900360640190fd5b6000808373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16106103f45783856103f7565b84845b909250905073ffffffffffffffffffffffffffffffffffffffff821661047e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f556e697377617056323a205a45524f5f41444452455353000000000000000000604482015290519081900360640190fd5b73ffffffffffffffffffffffffffffffffffffffff82811660009081526002602090815260408083208585168452909152902054161561051f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f556e697377617056323a20504149525f45584953545300000000000000000000604482015290519081900360640190fd5b6060604051806020016105319061086d565b6020820181038252601f19601f82011660405250905060008383604051602001808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1660601b81526014018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1660601b815260140192505050604051602081830303815290604052805190602001209050808251602084016000f5604080517f485cc95500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8781166004830152868116602483015291519297509087169163485cc9559160448082019260009290919082900301818387803b15801561065e57600080fd5b505af1158015610672573d6000803e3d6000fd5b5050505073ffffffffffffffffffffffffffffffffffffffff84811660008181526002602081815260408084208987168086529083528185208054978d167fffffffffffffffffffffffff000000000000000000000000000000000000000098891681179091559383528185208686528352818520805488168517905560038054600181018255958190527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b90950180549097168417909655925483519283529082015281517f0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31afa28d0e9929181900390910190a35050505092915050565b600260209081526000928352604080842090915290825290205473ffffffffffffffffffffffffffffffffffffffff1681565b60015473ffffffffffffffffffffffffffffffffffffffff16331461082657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f556e697377617056323a20464f5242494444454e000000000000000000000000604482015290519081900360640190fd5b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b612d748061087b8339019056fe60806040526001600c5534801561001557600080fd5b506040514690806052612d228239604080519182900360520182208282018252600a8352692ab734b9bbb0b8102b1960b11b6020938401528151808301835260018152603160f81b908401528151808401919091527fbfcc8ef98ffbf7b6c3fec7bf5185b566b9863e35a9d83acd49ad6824b5969738818301527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6606082015260808101949094523060a0808601919091528151808603909101815260c09094019052825192019190912060035550600580546001600160a01b03191633179055612c1d806101056000396000f3fe608060405234801561001057600080fd5b50600436106101b95760003560e01c80636a627842116100f9578063ba9a7a5611610097578063d21220a711610071578063d21220a7146105da578063d505accf146105e2578063dd62ed3e14610640578063fff6cae91461067b576101b9565b8063ba9a7a5614610597578063bc25cf771461059f578063c45a0155146105d2576101b9565b80637ecebe00116100d35780637ecebe00146104d757806389afcb441461050a57806395d89b4114610556578063a9059cbb1461055e576101b9565b80636a6278421461046957806370a082311461049c5780637464fc3d146104cf576101b9565b806323b872dd116101665780633644e515116101405780633644e51514610416578063485cc9551461041e5780635909c0d5146104595780635a3d549314610461576101b9565b806323b872dd146103ad57806330adf81f146103f0578063313ce567146103f8576101b9565b8063095ea7b311610197578063095ea7b3146103155780630dfe16811461036257806318160ddd14610393576101b9565b8063022c0d9f146101be57806306fdde03146102595780630902f1ac146102d6575b600080fd5b610257600480360360808110156101d457600080fd5b81359160208101359173ffffffffffffffffffffffffffffffffffffffff604083013516919081019060808101606082013564010000000081111561021857600080fd5b82018360208201111561022a57600080fd5b8035906020019184600183028401116401000000008311171561024c57600080fd5b509092509050610683565b005b610261610d57565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561029b578181015183820152602001610283565b50505050905090810190601f1680156102c85780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6102de610d90565b604080516dffffffffffffffffffffffffffff948516815292909316602083015263ffffffff168183015290519081900360600190f35b61034e6004803603604081101561032b57600080fd5b5073ffffffffffffffffffffffffffffffffffffffff8135169060200135610de5565b604080519115158252519081900360200190f35b61036a610dfc565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b61039b610e18565b60408051918252519081900360200190f35b61034e600480360360608110156103c357600080fd5b5073ffffffffffffffffffffffffffffffffffffffff813581169160208101359091169060400135610e1e565b61039b610efd565b610400610f21565b6040805160ff9092168252519081900360200190f35b61039b610f26565b6102576004803603604081101561043457600080fd5b5073ffffffffffffffffffffffffffffffffffffffff81358116916020013516610f2c565b61039b611005565b61039b61100b565b61039b6004803603602081101561047f57600080fd5b503573ffffffffffffffffffffffffffffffffffffffff16611011565b61039b600480360360208110156104b257600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166113cb565b61039b6113dd565b61039b600480360360208110156104ed57600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166113e3565b61053d6004803603602081101561052057600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166113f5565b6040805192835260208301919091528051918290030190f35b610261611892565b61034e6004803603604081101561057457600080fd5b5073ffffffffffffffffffffffffffffffffffffffff81351690602001356118cb565b61039b6118d8565b610257600480360360208110156105b557600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166118de565b61036a611ad4565b61036a611af0565b610257600480360360e08110156105f857600080fd5b5073ffffffffffffffffffffffffffffffffffffffff813581169160208101359091169060408101359060608101359060ff6080820135169060a08101359060c00135611b0c565b61039b6004803603604081101561065657600080fd5b5073ffffffffffffffffffffffffffffffffffffffff81358116916020013516611dd8565b610257611df5565b600c546001146106f457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c55841515806107075750600084115b61075c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526025815260200180612b2f6025913960400191505060405180910390fd5b600080610767610d90565b5091509150816dffffffffffffffffffffffffffff168710801561079a5750806dffffffffffffffffffffffffffff1686105b6107ef576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526021815260200180612b786021913960400191505060405180910390fd5b600654600754600091829173ffffffffffffffffffffffffffffffffffffffff91821691908116908916821480159061085457508073ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff1614155b6108bf57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f556e697377617056323a20494e56414c49445f544f0000000000000000000000604482015290519081900360640190fd5b8a156108d0576108d0828a8d611fdb565b89156108e1576108e1818a8c611fdb565b86156109c3578873ffffffffffffffffffffffffffffffffffffffff166310d1e85c338d8d8c8c6040518663ffffffff1660e01b8152600401808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f8201169050808301925050509650505050505050600060405180830381600087803b1580156109aa57600080fd5b505af11580156109be573d6000803e3d6000fd5b505050505b604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905173ffffffffffffffffffffffffffffffffffffffff8416916370a08231916024808301926020929190829003018186803b158015610a2f57600080fd5b505afa158015610a43573d6000803e3d6000fd5b505050506040513d6020811015610a5957600080fd5b5051604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905191955073ffffffffffffffffffffffffffffffffffffffff8316916370a0823191602480820192602092909190829003018186803b158015610acb57600080fd5b505afa158015610adf573d6000803e3d6000fd5b505050506040513d6020811015610af557600080fd5b5051925060009150506dffffffffffffffffffffffffffff85168a90038311610b1f576000610b35565b89856dffffffffffffffffffffffffffff160383035b9050600089856dffffffffffffffffffffffffffff16038311610b59576000610b6f565b89856dffffffffffffffffffffffffffff160383035b90506000821180610b805750600081115b610bd5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526024815260200180612b546024913960400191505060405180910390fd5b6000610c09610beb84600363ffffffff6121e816565b610bfd876103e863ffffffff6121e816565b9063ffffffff61226e16565b90506000610c21610beb84600363ffffffff6121e816565b9050610c59620f4240610c4d6dffffffffffffffffffffffffffff8b8116908b1663ffffffff6121e816565b9063ffffffff6121e816565b610c69838363ffffffff6121e816565b1015610cd657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f556e697377617056323a204b0000000000000000000000000000000000000000604482015290519081900360640190fd5b5050610ce4848488886122e0565b60408051838152602081018390528082018d9052606081018c9052905173ffffffffffffffffffffffffffffffffffffffff8b169133917fd78ad95fa46c994b6551d0da85fc275fe613ce37657fb8d5e3d130840159d8229181900360800190a350506001600c55505050505050505050565b6040518060400160405280600a81526020017f556e69737761702056320000000000000000000000000000000000000000000081525081565b6008546dffffffffffffffffffffffffffff808216926e0100000000000000000000000000008304909116917c0100000000000000000000000000000000000000000000000000000000900463ffffffff1690565b6000610df233848461259c565b5060015b92915050565b60065473ffffffffffffffffffffffffffffffffffffffff1681565b60005481565b73ffffffffffffffffffffffffffffffffffffffff831660009081526002602090815260408083203384529091528120547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff14610ee85773ffffffffffffffffffffffffffffffffffffffff84166000908152600260209081526040808320338452909152902054610eb6908363ffffffff61226e16565b73ffffffffffffffffffffffffffffffffffffffff851660009081526002602090815260408083203384529091529020555b610ef384848461260b565b5060019392505050565b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c981565b601281565b60035481565b60055473ffffffffffffffffffffffffffffffffffffffff163314610fb257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f556e697377617056323a20464f5242494444454e000000000000000000000000604482015290519081900360640190fd5b6006805473ffffffffffffffffffffffffffffffffffffffff9384167fffffffffffffffffffffffff00000000000000000000000000000000000000009182161790915560078054929093169116179055565b60095481565b600a5481565b6000600c5460011461108457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c81905580611094610d90565b50600654604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905193955091935060009273ffffffffffffffffffffffffffffffffffffffff909116916370a08231916024808301926020929190829003018186803b15801561110e57600080fd5b505afa158015611122573d6000803e3d6000fd5b505050506040513d602081101561113857600080fd5b5051600754604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905192935060009273ffffffffffffffffffffffffffffffffffffffff909216916370a0823191602480820192602092909190829003018186803b1580156111b157600080fd5b505afa1580156111c5573d6000803e3d6000fd5b505050506040513d60208110156111db57600080fd5b505190506000611201836dffffffffffffffffffffffffffff871663ffffffff61226e16565b90506000611225836dffffffffffffffffffffffffffff871663ffffffff61226e16565b9050600061123387876126ec565b600054909150806112705761125c6103e8610bfd611257878763ffffffff6121e816565b612878565b985061126b60006103e86128ca565b6112cd565b6112ca6dffffffffffffffffffffffffffff8916611294868463ffffffff6121e816565b8161129b57fe5b046dffffffffffffffffffffffffffff89166112bd868563ffffffff6121e816565b816112c457fe5b0461297a565b98505b60008911611326576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526028815260200180612bc16028913960400191505060405180910390fd5b6113308a8a6128ca565b61133c86868a8a6122e0565b811561137e5760085461137a906dffffffffffffffffffffffffffff808216916e01000000000000000000000000000090041663ffffffff6121e816565b600b555b6040805185815260208101859052815133927f4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f928290030190a250506001600c5550949695505050505050565b60016020526000908152604090205481565b600b5481565b60046020526000908152604090205481565b600080600c5460011461146957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c81905580611479610d90565b50600654600754604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905194965092945073ffffffffffffffffffffffffffffffffffffffff9182169391169160009184916370a08231916024808301926020929190829003018186803b1580156114fb57600080fd5b505afa15801561150f573d6000803e3d6000fd5b505050506040513d602081101561152557600080fd5b5051604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905191925060009173ffffffffffffffffffffffffffffffffffffffff8516916370a08231916024808301926020929190829003018186803b15801561159957600080fd5b505afa1580156115ad573d6000803e3d6000fd5b505050506040513d60208110156115c357600080fd5b5051306000908152600160205260408120549192506115e288886126ec565b600054909150806115f9848763ffffffff6121e816565b8161160057fe5b049a5080611614848663ffffffff6121e816565b8161161b57fe5b04995060008b11801561162e575060008a115b611683576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526028815260200180612b996028913960400191505060405180910390fd5b61168d3084612992565b611698878d8d611fdb565b6116a3868d8c611fdb565b604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905173ffffffffffffffffffffffffffffffffffffffff8916916370a08231916024808301926020929190829003018186803b15801561170f57600080fd5b505afa158015611723573d6000803e3d6000fd5b505050506040513d602081101561173957600080fd5b5051604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905191965073ffffffffffffffffffffffffffffffffffffffff8816916370a0823191602480820192602092909190829003018186803b1580156117ab57600080fd5b505afa1580156117bf573d6000803e3d6000fd5b505050506040513d60208110156117d557600080fd5b505193506117e585858b8b6122e0565b811561182757600854611823906dffffffffffffffffffffffffffff808216916e01000000000000000000000000000090041663ffffffff6121e816565b600b555b604080518c8152602081018c9052815173ffffffffffffffffffffffffffffffffffffffff8f169233927fdccd412f0b1252819cb1fd330b93224ca42612892bb3f4f789976e6d81936496929081900390910190a35050505050505050506001600c81905550915091565b6040518060400160405280600681526020017f554e492d5632000000000000000000000000000000000000000000000000000081525081565b6000610df233848461260b565b6103e881565b600c5460011461194f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c55600654600754600854604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905173ffffffffffffffffffffffffffffffffffffffff9485169490931692611a2b9285928792611a26926dffffffffffffffffffffffffffff169185916370a0823191602480820192602092909190829003018186803b1580156119ee57600080fd5b505afa158015611a02573d6000803e3d6000fd5b505050506040513d6020811015611a1857600080fd5b50519063ffffffff61226e16565b611fdb565b600854604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051611aca9284928792611a26926e01000000000000000000000000000090046dffffffffffffffffffffffffffff169173ffffffffffffffffffffffffffffffffffffffff8616916370a0823191602480820192602092909190829003018186803b1580156119ee57600080fd5b50506001600c5550565b60055473ffffffffffffffffffffffffffffffffffffffff1681565b60075473ffffffffffffffffffffffffffffffffffffffff1681565b42841015611b7b57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f556e697377617056323a20455850495245440000000000000000000000000000604482015290519081900360640190fd5b60035473ffffffffffffffffffffffffffffffffffffffff80891660008181526004602090815260408083208054600180820190925582517f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98186015280840196909652958d166060860152608085018c905260a085019590955260c08085018b90528151808603909101815260e0850182528051908301207f19010000000000000000000000000000000000000000000000000000000000006101008601526101028501969096526101228085019690965280518085039096018652610142840180825286519683019690962095839052610162840180825286905260ff89166101828501526101a284018890526101c28401879052519193926101e2808201937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081019281900390910190855afa158015611cdc573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff811615801590611d5757508873ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b611dc257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f556e697377617056323a20494e56414c49445f5349474e415455524500000000604482015290519081900360640190fd5b611dcd89898961259c565b505050505050505050565b600260209081526000928352604080842090915290825290205481565b600c54600114611e6657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c55600654604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051611fd49273ffffffffffffffffffffffffffffffffffffffff16916370a08231916024808301926020929190829003018186803b158015611edd57600080fd5b505afa158015611ef1573d6000803e3d6000fd5b505050506040513d6020811015611f0757600080fd5b5051600754604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905173ffffffffffffffffffffffffffffffffffffffff909216916370a0823191602480820192602092909190829003018186803b158015611f7a57600080fd5b505afa158015611f8e573d6000803e3d6000fd5b505050506040513d6020811015611fa457600080fd5b50516008546dffffffffffffffffffffffffffff808216916e0100000000000000000000000000009004166122e0565b6001600c55565b604080518082018252601981527f7472616e7366657228616464726573732c75696e743235362900000000000000602091820152815173ffffffffffffffffffffffffffffffffffffffff85811660248301526044808301869052845180840390910181526064909201845291810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb000000000000000000000000000000000000000000000000000000001781529251815160009460609489169392918291908083835b602083106120e157805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920191602091820191016120a4565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114612143576040519150601f19603f3d011682016040523d82523d6000602084013e612148565b606091505b5091509150818015612176575080511580612176575080806020019051602081101561217357600080fd5b50515b6121e157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f556e697377617056323a205452414e534645525f4641494c4544000000000000604482015290519081900360640190fd5b5050505050565b60008115806122035750508082028282828161220057fe5b04145b610df657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f64732d6d6174682d6d756c2d6f766572666c6f77000000000000000000000000604482015290519081900360640190fd5b80820382811115610df657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f64732d6d6174682d7375622d756e646572666c6f770000000000000000000000604482015290519081900360640190fd5b6dffffffffffffffffffffffffffff841180159061230c57506dffffffffffffffffffffffffffff8311155b61237757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f556e697377617056323a204f564552464c4f5700000000000000000000000000604482015290519081900360640190fd5b60085463ffffffff428116917c0100000000000000000000000000000000000000000000000000000000900481168203908116158015906123c757506dffffffffffffffffffffffffffff841615155b80156123e257506dffffffffffffffffffffffffffff831615155b15612492578063ffffffff16612425856123fb86612a57565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff169063ffffffff612a7b16565b600980547bffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092169290920201905563ffffffff8116612465846123fb87612a57565b600a80547bffffffffffffffffffffffffffffffffffffffffffffffffffffffff92909216929092020190555b600880547fffffffffffffffffffffffffffffffffffff0000000000000000000000000000166dffffffffffffffffffffffffffff888116919091177fffffffff0000000000000000000000000000ffffffffffffffffffffffffffff166e0100000000000000000000000000008883168102919091177bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167c010000000000000000000000000000000000000000000000000000000063ffffffff871602179283905560408051848416815291909304909116602082015281517f1c411e9a96e071241c2f21f7726b17ae89e3cab4c78be50e062b03a9fffbbad1929181900390910190a1505050505050565b73ffffffffffffffffffffffffffffffffffffffff808416600081815260026020908152604080832094871680845294825291829020859055815185815291517f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259281900390910190a3505050565b73ffffffffffffffffffffffffffffffffffffffff8316600090815260016020526040902054612641908263ffffffff61226e16565b73ffffffffffffffffffffffffffffffffffffffff8085166000908152600160205260408082209390935590841681522054612683908263ffffffff612abc16565b73ffffffffffffffffffffffffffffffffffffffff80841660008181526001602090815260409182902094909455805185815290519193928716927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef92918290030190a3505050565b600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663017e7e586040518163ffffffff1660e01b815260040160206040518083038186803b15801561275757600080fd5b505afa15801561276b573d6000803e3d6000fd5b505050506040513d602081101561278157600080fd5b5051600b5473ffffffffffffffffffffffffffffffffffffffff821615801594509192509061286457801561285f5760006127d86112576dffffffffffffffffffffffffffff88811690881663ffffffff6121e816565b905060006127e583612878565b90508082111561285c576000612813612804848463ffffffff61226e16565b6000549063ffffffff6121e816565b905060006128388361282c86600563ffffffff6121e816565b9063ffffffff612abc16565b9050600081838161284557fe5b04905080156128585761285887826128ca565b5050505b50505b612870565b8015612870576000600b555b505092915050565b600060038211156128bb575080600160028204015b818110156128b5578091506002818285816128a457fe5b0401816128ad57fe5b04905061288d565b506128c5565b81156128c5575060015b919050565b6000546128dd908263ffffffff612abc16565b600090815573ffffffffffffffffffffffffffffffffffffffff8316815260016020526040902054612915908263ffffffff612abc16565b73ffffffffffffffffffffffffffffffffffffffff831660008181526001602090815260408083209490945583518581529351929391927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9281900390910190a35050565b6000818310612989578161298b565b825b9392505050565b73ffffffffffffffffffffffffffffffffffffffff82166000908152600160205260409020546129c8908263ffffffff61226e16565b73ffffffffffffffffffffffffffffffffffffffff831660009081526001602052604081209190915554612a02908263ffffffff61226e16565b600090815560408051838152905173ffffffffffffffffffffffffffffffffffffffff8516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef919081900360200190a35050565b6dffffffffffffffffffffffffffff166e0100000000000000000000000000000290565b60006dffffffffffffffffffffffffffff82167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff841681612ab457fe5b049392505050565b80820182811015610df657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f64732d6d6174682d6164642d6f766572666c6f77000000000000000000000000604482015290519081900360640190fdfe556e697377617056323a20494e53554646494349454e545f4f55545055545f414d4f554e54556e697377617056323a20494e53554646494349454e545f494e5055545f414d4f554e54556e697377617056323a20494e53554646494349454e545f4c4951554944495459556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e4544556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e544544a265627a7a723158207dca18479e58487606bf70c79e44d8dee62353c9ee6d01f9a9d70885b8765f2264736f6c63430005100032454950373132446f6d61696e28737472696e67206e616d652c737472696e672076657273696f6e2c75696e7432353620636861696e49642c6164647265737320766572696679696e67436f6e747261637429a265627a7a723158202760f92d7fa1db6f5aa16307bad65df4ebcc8550c4b1f03755ab8dfd830c178f64736f6c63430005100032000000000000000000000000{_sender}";

    impl PlanConfig<String> for MockConfig {
        fn get_env(&self) -> std::result::Result<HashMap<String, String>, GeneratorError> {
            Ok(HashMap::<String, String>::from_iter([
                ("test1".to_owned(), "0xbeef".to_owned()),
                ("test2".to_owned(), "0x9001".to_owned()),
            ]))
        }

        fn get_create_steps(&self) -> std::result::Result<Vec<CreateDefinition>, GeneratorError> {
            Ok(vec![
                CreateDefinition {
                    contract: CompiledContract {
                        bytecode: COUNTER_BYTECODE.to_string(),
                        name: "test_counter2".to_string(),
                    },
                    signature: None,
                    args: None,
                    from: None,
                    from_pool: Some("admin1".to_owned()),
                },
                CreateDefinition {
                    contract: CompiledContract {
                        bytecode: UNI_V2_FACTORY_BYTECODE.to_string(),
                        name: "univ2_factory".to_string(),
                    },
                    signature: None,
                    args: None,
                    from: None,
                    from_pool: Some("admin2".to_owned()),
                },
            ])
        }

        fn get_setup_steps(
            &self,
        ) -> std::result::Result<Vec<FunctionCallDefinition>, GeneratorError> {
            Ok(vec![
                FunctionCallDefinition::new("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D")
                    .with_from("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266")
                    .with_value(U256::from(4096))
                    .with_signature("swap(uint256 x, uint256 y, address a, bytes b)")
                    .with_args(&[
                        "1".to_owned(),
                        "2".to_owned(),
                        Address::repeat_byte(0x11).encode_hex(),
                        "0xdead".to_owned(),
                    ]),
                FunctionCallDefinition::new("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D")
                    .with_from("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266")
                    .with_value(U256::from(0x1000))
                    .with_signature("swap(uint256 x, uint256 y, address a, bytes b)")
                    .with_args(&[
                        "1".to_owned(),
                        "2".to_owned(),
                        Address::repeat_byte(0x11).encode_hex(),
                        "0xbeef".to_owned(),
                    ]),
                FunctionCallDefinition::new("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D")
                    .with_from_pool("pool1")
                    .with_signature("increment()"),
            ])
        }

        fn get_spam_steps(&self) -> std::result::Result<Vec<SpamRequest>, GeneratorError> {
            Ok(vec![
                SpamRequest::Tx(
                    FunctionCallDefinition::new("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D")
                        .with_from_pool("pool1")
                        .with_signature("swap(uint256 x, uint256 y, address a, bytes b)")
                        .with_args(&[
                            "1".to_owned(),
                            "2".to_owned(),
                            // {_sender} will be replaced with the `from` address
                            "{_sender}".to_owned(),
                            "0xd00d".to_owned(),
                        ])
                        .with_fuzz(&[FuzzParam {
                            param: Some("x".to_string()),
                            value: None,
                            min: None,
                            max: None,
                        }])
                        .into(),
                ),
                SpamRequest::Tx(
                    FunctionCallDefinition::new("0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D")
                        .with_from_pool("pool2")
                        .with_signature("swap(uint256 x, uint256 y, address a, bytes b)")
                        .with_args(&[
                            "1".to_owned(),
                            "2".to_owned(),
                            // {_sender} will be replaced with the `from` address
                            "{_sender}".to_owned(),
                            "0xd00d".to_owned(),
                        ])
                        .with_fuzz(&[FuzzParam {
                            param: Some("x".to_string()),
                            value: None,
                            min: None,
                            max: None,
                        }])
                        .into(),
                ),
                SpamRequest::Tx(
                    FunctionCallDefinition::new("0x00000000000000000000000000000000f007ba11")
                        .with_from_pool("pool2")
                        .with_signature("swap(uint256 x, uint256 y, address a, bytes b)")
                        .with_args(&[
                            "1".to_owned(),
                            "2".to_owned(),
                            // {_sender} will be replaced with the `from` address
                            "{_sender}".to_owned(),
                            "0xd00d".to_owned(),
                        ])
                        .with_fuzz(&[FuzzParam {
                            param: Some("x".to_string()),
                            value: None,
                            min: None,
                            max: None,
                        }])
                        .with_gas_limit(100_000)
                        .into(),
                ),
            ])
        }
    }

    impl Templater<String> for MockConfig {
        fn copy_end(&self, input: &str, _last_end: usize) -> String {
            input.to_owned()
        }
        fn replace_placeholders(
            &self,
            input: &str,
            _placeholder_map: &std::collections::HashMap<String, String>,
        ) -> String {
            input.to_owned()
        }
        fn terminator_start(&self, _input: &str) -> Option<usize> {
            None
        }
        fn terminator_end(&self, _input: &str) -> Option<usize> {
            None
        }
        fn num_placeholders(&self, _input: &str) -> usize {
            0
        }
        fn find_key(&self, _input: &str) -> Option<(String, usize)> {
            None
        }
    }

    pub async fn get_test_scenario(
        anvil: &AnvilInstance,
        txs_per_duration: u64,
        builder_anvil: Option<&AnvilInstance>,
        gas_price: Option<U256>,
    ) -> Result<TestScenario<MockDb, RandSeed, MockConfig>> {
        let seed = RandSeed::new();
        let tx_type = alloy::consensus::TxType::Eip1559;
        let bundle_type = BundleType::default();
        let signers = get_test_signers();
        let fund_amount_eth = 25.0;

        println!("anvil endpoint: {}", anvil.endpoint_url());

        let mut agents = AgentStore::new();
        let config = MockConfig;
        let num_pools = config.get_spam_pools().len().max(1) as u64;
        println!("spam pools: {num_pools}, txs_per_duration: {txs_per_duration}");
        agents.init(
            &["pool1", "pool2"],
            (txs_per_duration / num_pools) as usize,
            &seed,
        );
        agents.init(&["admin1", "admin2"], 1, &seed);

        let mut scenario = TestScenario::new(
            config,
            MockDb.into(),
            seed.to_owned(),
            TestScenarioParams {
                rpc_url: anvil.endpoint_url(),
                builder_rpc_url: builder_anvil.map(|anvil| anvil.endpoint_url()),
                signers: signers.to_owned(),
                agent_store: agents,
                tx_type,
                bundle_type,
                pending_tx_timeout_secs: 12,
                extra_msg_handles: None,
                redeploy: true,
                sync_nonces_after_batch: true,
                rpc_batch_size: 0,
                gas_price,
            },
            None,
            (&PROM, &HIST).into(),
        )
        .await?;

        let fund_amount_wei = U256::from(fund_amount_eth * 1e18);
        println!("fund_amount_wei: {fund_amount_wei}");
        println!("fund_amount_eth: {fund_amount_eth}");
        println!("fund_amount eth: {}", format_ether(fund_amount_wei));

        for (name, agent) in scenario.agent_store.all_agents() {
            println!(
                "funding agent: {name} (num signers: {})",
                agent.signers.len()
            );
            let funder_balance = scenario
                .rpc_client
                .get_balance(anvil.wallet().unwrap().default_signer().address())
                .await
                .unwrap();
            println!("funder balance: {}", format_ether(funder_balance));
            agent
                .fund_signers(&signers[0], fund_amount_wei, scenario.rpc_client.clone())
                .await
                .unwrap();
        }

        // Only apply default gas_price_adder when no override is set
        if gas_price.is_none() {
            scenario.ctx.add_to_gas_price(GWEI_TO_WEI as i128 * 10);
        }

        Ok(scenario)
    }

    #[tokio::test]
    async fn it_creates_scenarios() -> std::result::Result<(), Box<dyn std::error::Error>> {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, None, None).await?;

        let (create_txs, _nonces) = scenario
            .load_txs(PlanType::Create(|tx| {
                println!("create tx callback triggered! name: {:?}\n", tx.name);
                Ok(None)
            }))
            .await?;
        assert_eq!(create_txs.len(), 2);

        let (setup_txs, _nonces) = scenario
            .load_txs(PlanType::Setup(|tx| {
                println!("setup tx callback triggered! name: {:?}\n", tx.name);
                Ok(None)
            }))
            .await?;
        assert_eq!(setup_txs.len(), 3);

        let (spam_txs, _nonces) = scenario
            .load_txs(PlanType::Spam(20, |tx| {
                println!("spam tx callback triggered! name: {:?}\n", tx.name);
                Ok(None)
            }))
            .await?;

        // should round up to nearest multiple of 3 (3 spam steps in config, 20 txs requested)
        assert_eq!(spam_txs.len(), 21);
        Ok(())
    }

    #[tokio::test]
    async fn gas_limit_override_works() {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, None, None).await.unwrap();
        let (spam_txs, _nonces) = scenario
            .load_txs(PlanType::Spam(20, |tx| {
                println!("spam tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await
            .unwrap();
        let tx = spam_txs
            .iter()
            .find(|tx| match tx {
                ExecutionRequest::Tx(tx) => {
                    *tx.tx.to.unwrap().to().unwrap()
                        == "0x00000000000000000000000000000000f007ba11"
                            .parse::<Address>()
                            .unwrap()
                }
                _ => false,
            })
            .unwrap();
        match tx {
            ExecutionRequest::Tx(tx) => {
                assert_eq!(tx.tx.gas, Some(100_000));
            }
            _ => panic!("expected tx"),
        }
    }

    #[tokio::test]
    async fn rpc_batch_size_controls_num_rpc_batches_sent() -> Result<()> {
        // --- Common setup ---
        let txs_per_duration: u64 = 35;
        let num_periods = 2;
        let total_txs = txs_per_duration * num_periods;
        let anvil = spawn_anvil();

        // --- Non-batched case: rpc_batch_size = 0 ---
        let mut scenario = get_test_scenario(&anvil, txs_per_duration, None, None).await?;
        scenario.rpc_batch_size = 0;

        let spammer = BlockwiseSpammer::new();
        let callback = NilCallback;

        spammer
            .spam_rpc(
                &mut scenario,
                txs_per_duration,
                num_periods,
                None,
                Arc::new(callback),
            )
            .await?;

        // With no bundles and rpc_batch_size = 0, each payload is sent in its own "batch".
        assert_eq!(scenario.num_rpc_batches_sent, total_txs);

        // --- Batched case: rpc_batch_size = 10 ---
        let mut scenario_batched = get_test_scenario(&anvil, txs_per_duration, None, None).await?;
        scenario_batched.rpc_batch_size = 10;

        let spammer_batched = BlockwiseSpammer::new();
        let callback_batched = NilCallback;

        spammer_batched
            .spam_rpc(
                &mut scenario_batched,
                txs_per_duration,
                num_periods,
                None,
                Arc::new(callback_batched),
            )
            .await?;

        let remaining = txs_per_duration % scenario_batched.rpc_batch_size;
        let expected_batches = ((txs_per_duration / scenario_batched.rpc_batch_size)
            + (if remaining > 0 { 1 } else { 0 }))
            * num_periods;
        assert_eq!(scenario_batched.num_rpc_batches_sent, expected_batches);

        Ok(())
    }

    #[tokio::test]
    async fn fncall_replaces_sender_placeholder_with_from_address() {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, None, None).await.unwrap();

        let (spam_txs, _nonces) = scenario
            .load_txs(PlanType::Spam(10, |tx| {
                println!("spam tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await
            .unwrap();
        let spam_tx = &spam_txs[0];
        let tx = match spam_tx {
            ExecutionRequest::Tx(tx) => tx,
            _ => panic!("expected tx"),
        };
        let from = tx.tx.from.unwrap();
        let input = tx.tx.input.input.as_ref().unwrap();
        println!("input: {input}");
        println!("from: {}", from.encode_hex());
        assert!(input.encode_hex().contains(&from.encode_hex()));
    }

    #[tokio::test]
    async fn create_replaces_sender_placeholder_with_from_address() {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, None, None).await.unwrap();

        let (txs, _nonces) = scenario
            .load_txs(PlanType::Create(|tx| {
                println!("create tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await
            .unwrap();

        // 2nd tx should have from address in its bytecode when we deploy it
        let sample_tx = &txs[1];
        let tx = match sample_tx {
            ExecutionRequest::Tx(tx) => tx,
            _ => panic!("expected tx"),
        };
        let from = tx.tx.from.unwrap();
        let input = tx.tx.input.input.as_ref().unwrap();
        println!("input: {input}");
        println!("from: {}", from.encode_hex());
        assert!(input.encode_hex().contains(&from.encode_hex()));
    }

    #[tokio::test]
    async fn create_steps_use_agent_signers() {
        let anvil = spawn_anvil();
        let mut scenario = get_test_scenario(&anvil, 10, None, None).await.unwrap();
        scenario.deploy_contracts().await.unwrap();

        // assert that the agent store has the correct number of signers
        let (create_steps, _nonces) = scenario
            .load_txs(PlanType::Create(|_| Ok(None)))
            .await
            .unwrap();
        let mut used_agent_keys = 0;
        for step in create_steps {
            let tx = match step {
                ExecutionRequest::Tx(tx) => tx,
                _ => continue,
            };
            if let Some(from_addr) = tx.tx.from {
                assert!(scenario.signer_map.contains_key(&from_addr));
            }
            let admin_pools = ["admin1", "admin2"];
            for pool in admin_pools {
                if scenario
                    .agent_store
                    .get_agent(pool)
                    .unwrap()
                    .signers
                    .iter()
                    .map(|s| s.address())
                    .collect::<Vec<_>>()
                    .contains(&tx.tx.from.unwrap())
                {
                    used_agent_keys += 1;
                }
            }
        }
        assert_eq!(used_agent_keys, 2);
    }

    #[tokio::test]
    async fn setup_steps_use_agent_signers() {
        let anvil = spawn_anvil();
        let mut scenario = get_test_scenario(&anvil, 10, None, None).await.unwrap();
        scenario.deploy_contracts().await.unwrap();
        let (setup_steps, _nonces) = scenario
            .load_txs(PlanType::Setup(|_| Ok(None)))
            .await
            .unwrap();
        scenario.run_setup().await.unwrap();
        let mut used_agent_keys = 0;
        for step in setup_steps {
            let tx = match step {
                ExecutionRequest::Tx(tx) => tx,
                _ => continue,
            };
            let from = tx.tx.from.unwrap();
            assert!(scenario.signer_map.contains_key(&from));
            assert!(scenario.agent_store.has_agent("pool1"));
            if scenario
                .agent_store
                .get_agent("pool1")
                .unwrap()
                .signers
                .iter()
                .map(|s| s.address())
                .collect::<Vec<_>>()
                .contains(&from)
            {
                used_agent_keys += 1;
            }
        }
        assert_eq!(used_agent_keys, 1);
    }

    #[tokio::test]
    async fn scenario_creates_contracts() {
        let anvil = spawn_anvil();
        let mut scenario = get_test_scenario(&anvil, 10, None, None).await.unwrap();
        let res = scenario.deploy_contracts().await;
        assert!(res.is_ok());
    }

    #[tokio::test]
    async fn scenario_runs_setup() {
        let anvil = spawn_anvil();
        let mut scenario = get_test_scenario(&anvil, 10, None, None).await.unwrap();
        scenario.deploy_contracts().await.unwrap();
        let res = scenario.run_setup().await;
        println!("{res:?}");
        assert!(res.is_ok());
    }

    #[tokio::test]
    async fn setup_cost_estimates_are_correct(
    ) -> std::result::Result<(), Box<dyn std::error::Error>> {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, None, None).await.unwrap();
        let cost = scenario.estimate_setup_cost().await?;
        let total_txs = scenario.config.get_setup_steps().unwrap().len()
            + scenario.config.get_create_steps().unwrap().len();
        let expected_cost_min = U256::from(GWEI_TO_WEI * 21000 * total_txs as u64); // assuming gas price is 1 gwei and txs are cheap
        assert!(cost > expected_cost_min);
        Ok(())
    }

    #[tokio::test]
    async fn all_tx_requests_are_contiguous() -> std::result::Result<(), Box<dyn std::error::Error>>
    {
        let anvil = spawn_anvil();
        let txs_per_duration = 50u64;
        let duration = 3;
        let mut scenario = get_test_scenario(&anvil, txs_per_duration, None, None).await?;

        // make tx chunks
        let tx_req_chunks = scenario
            .get_spam_tx_chunks(txs_per_duration, duration)
            .await?;

        // test chunk size & count
        assert_eq!(tx_req_chunks.len(), duration as usize);
        for chunk in tx_req_chunks.iter() {
            assert_eq!(chunk.len(), txs_per_duration as usize);
        }

        // prepare tx requests & collect them all into a single array
        let mut prepared_txs: Vec<crate::spammer::ExecutionPayload> = vec![];
        for chunk in tx_req_chunks {
            let tx_reqs = scenario.prepare_spam(&chunk).await?;
            prepared_txs.extend(tx_reqs);
        }

        // group prepared_txs by `from` address, then sort each group by nonce, then assert that all nonces are contiguous (no gaps)
        let mut grouped_txs = std::collections::HashMap::new();
        for tx in &prepared_txs {
            match tx {
                crate::spammer::ExecutionPayload::SignedTx(_, tx_req) => {
                    let from = tx_req.tx.from.unwrap();
                    let nonce = tx_req.tx.nonce.unwrap();
                    grouped_txs.entry(from).or_insert_with(Vec::new).push(nonce);
                }
                crate::spammer::ExecutionPayload::SignedTxBundle(_, _) => {
                    // ignore
                }
            }
        }
        for (from, nonces) in grouped_txs {
            let mut nonces = nonces;
            nonces.sort();
            let mut prev_nonce = nonces[0];
            let mut min_nonce = prev_nonce;
            let mut max_nonce = prev_nonce;
            for nonce in &nonces[1..] {
                assert_eq!(prev_nonce + 1, *nonce);
                prev_nonce = *nonce;
                if *nonce < min_nonce {
                    min_nonce = *nonce;
                }
                if *nonce > max_nonce {
                    max_nonce = *nonce;
                }
            }
            println!("({from}) min_nonce: {min_nonce}, max_nonce: {max_nonce}");
        }

        Ok(())
    }

    #[tokio::test]
    async fn new_scenario_rejects_mismatched_chain_ids() {
        let anvil = spawn_anvil();
        let anvil2 = Anvil::new().chain_id(12321).spawn();
        let scenario = get_test_scenario(&anvil, 10, Some(&anvil2), None).await;

        if let Err(e) = scenario {
            println!("error (this is part of the test): {e}");
            assert!(matches!(
                e,
                Error::Runtime(RuntimeErrorKind::ChainIdMismatch(_, _))
            ));
        } else {
            panic!("scenario should not return Ok if chain IDs don't match");
        }
    }

    #[tokio::test]
    async fn gas_price_override_skips_gas_price_adder() -> Result<()> {
        let anvil = spawn_anvil();

        // Set a fixed gas price override of 5 gwei
        let override_gas_price = U256::from(5 * GWEI_TO_WEI);
        let mut scenario = get_test_scenario(&anvil, 10, None, Some(override_gas_price)).await?;

        // Add a significant gas_price_adder (10 gwei) - this should be ignored when override is set
        scenario.ctx.add_to_gas_price(GWEI_TO_WEI as i128 * 10);

        let (spam_txs, _nonces) = scenario
            .load_txs(PlanType::Spam(10, |_tx| Ok(None)))
            .await?;

        let prepared_txs = scenario.prepare_spam(&spam_txs).await?;

        // Verify that all transactions use the override gas price, not network price + adder
        for payload in prepared_txs {
            if let crate::spammer::ExecutionPayload::SignedTx(_, tx_req) = payload {
                let max_fee = tx_req.tx.max_fee_per_gas.unwrap_or(0);
                let expected_max_fee = override_gas_price.to::<u128>();

                assert_eq!(
                    max_fee, expected_max_fee,
                    "Gas price should use override ({}), not be affected by gas_price_adder. Got: {}",
                    expected_max_fee, max_fee
                );
            }
        }

        Ok(())
    }
}
