use crate::agent_controller::AgentStore;
use crate::buckets::Bucket;
use crate::db::{DbOps, NamedTx};
use crate::error::ContenderError;
use crate::generator::named_txs::ExecutionRequest;
use crate::generator::templater::Templater;
use crate::generator::types::AnyProvider;
use crate::generator::util::complete_tx_request;
use crate::generator::NamedTxRequest;
use crate::generator::{seeder::Seeder, types::PlanType, Generator, PlanConfig};
use crate::provider::{LoggingLayer, RPC_REQUEST_LATENCY_ID};
use crate::spammer::tx_actor::TxActorHandle;
use crate::spammer::{ExecutionPayload, OnBatchSent, OnTxSent, SpamTrigger};
use crate::Result;
use alloy::consensus::constants::{ETH_TO_WEI, GWEI_TO_WEI};
use alloy::consensus::{Transaction, TxType};
use alloy::eips::eip2718::Encodable2718;
use alloy::hex::ToHexExt;
use alloy::network::{AnyNetwork, AnyTxEnvelope, EthereumWallet, TransactionBuilder};
use alloy::node_bindings::Anvil;
use alloy::primitives::{keccak256, Address, FixedBytes, U256};
use alloy::providers::{DynProvider, PendingTransactionConfig, Provider, ProviderBuilder};
use alloy::rpc::client::ClientBuilder;
use alloy::rpc::types::TransactionRequest;
use alloy::serde::WithOtherFields;
use alloy::signers::local::{LocalSigner, PrivateKeySigner};
use alloy::transports::http::reqwest::Url;
use contender_bundle_provider::bundle_provider::new_basic_bundle;
use contender_bundle_provider::BundleClient;
use contender_engine_provider::AdvanceChain;
use futures::{Stream, StreamExt};
use std::collections::{BTreeMap, HashMap};
use std::ops::Deref;
use std::pin::Pin;
use std::str::FromStr;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::OnceCell;
use tokio_util::sync::CancellationToken;

type PrometheusCollector = (
    &'static OnceCell<prometheus::Registry>,
    &'static OnceCell<prometheus::HistogramVec>,
);

/// A test scenario can be used to run a test with a specific configuration, database, and RPC provider.
#[derive(Clone)]
pub struct TestScenario<D, S, P>
where
    D: DbOps + Send + Sync + 'static,
    S: Seeder,
    P: PlanConfig<String> + Templater<String> + Send + Sync,
{
    pub config: P,
    pub db: Arc<D>,
    pub rpc_url: Url,
    pub rpc_client: Arc<AnyProvider>,
    pub bundle_client: Option<Arc<BundleClient>>,
    pub builder_rpc_url: Option<Url>,
    pub rand_seed: S,
    /// Wallets explicitly given by the user
    pub wallet_map: HashMap<Address, EthereumWallet>,
    /// Wallets generated by the system
    pub agent_store: AgentStore,
    pub nonces: HashMap<Address, u64>,
    pub chain_id: u64,
    pub gas_limits: HashMap<FixedBytes<32>, u64>,
    pub msg_handle: Arc<TxActorHandle>,
    pub tx_type: TxType,
    pub gas_price_percent_add: u64,
    pub pending_tx_timeout_secs: u64,
    pub ctx: ExecutionContext,
    pub auth_provider: Option<Arc<dyn AdvanceChain + Send + Sync + 'static>>,
    prometheus: PrometheusCollector,
}

pub struct TestScenarioParams {
    pub rpc_url: Url,
    pub builder_rpc_url: Option<Url>,
    pub signers: Vec<PrivateKeySigner>,
    pub agent_store: AgentStore,
    pub tx_type: TxType,
    pub gas_price_percent_add: Option<u64>,
    pub pending_tx_timeout_secs: u64,
}

#[derive(Clone)]
pub struct ExecutionContext {
    /// Adds this amount of wei per gas to the gas price given to each transaction. May be negative to subtract gas.
    /// This is not the same as the `gas_price_percent_add`, which is a percentage of the gas price provided by the user.
    gas_price_adder: i128,
    /// The amount of time between blocks on the target chain.
    pub block_time_secs: u64,
    /// Tells us when to terminate async tasks.
    pub cancel_token: CancellationToken,
}

impl ExecutionContext {
    pub fn add_to_gas_price(&mut self, amount: i128) {
        self.gas_price_adder += amount;
    }
}

impl<D, S, P> TestScenario<D, S, P>
where
    D: DbOps + Send + Sync + 'static,
    S: Seeder + Send + Sync + Clone,
    P: PlanConfig<String> + Templater<String> + Send + Sync + Clone,
{
    pub async fn new(
        config: P,
        db: Arc<D>,
        rand_seed: S,
        params: TestScenarioParams,
        auth_provider: Option<Arc<dyn AdvanceChain + Send + Sync + 'static>>,
        prometheus: PrometheusCollector,
    ) -> Result<Self> {
        let TestScenarioParams {
            rpc_url,
            builder_rpc_url,
            signers,
            agent_store,
            tx_type,
            gas_price_percent_add,
            pending_tx_timeout_secs,
        } = params;

        // use custom logging layer to log sendRawTransaction request IDs
        let client = ClientBuilder::default()
            .layer(LoggingLayer::new(prometheus.0, prometheus.1).await)
            .http(rpc_url.to_owned());
        let rpc_client = Arc::new(DynProvider::new(
            ProviderBuilder::new()
                .network::<AnyNetwork>()
                .on_client(client),
        ));

        // derive block time from last two blocks. if two blocks don't exist, assume block time is 1s
        let block_num = rpc_client
            .get_block_number()
            .await
            .map_err(|e| ContenderError::with_err(e, "failed to get block number"))?;
        let block_time_secs = if block_num > 0 {
            let mut timestamps = vec![];
            for i in [0_u64, 1] {
                let block = rpc_client
                    .get_block_by_number((block_num - i).into())
                    .await
                    .map_err(|e| ContenderError::with_err(e, "failed to get block"))?;
                if let Some(block) = block {
                    timestamps.push(block.header.timestamp);
                }
            }
            if timestamps.len() == 2 {
                (timestamps[0] - timestamps[1]).max(1)
            } else {
                1
            }
        } else {
            1
        };

        let mut wallet_map = HashMap::new();
        let wallets = signers.iter().map(|s| {
            let w = EthereumWallet::new(s.clone());
            (s.address(), w)
        });
        for (addr, wallet) in wallets {
            wallet_map.insert(addr, wallet);
        }
        for (name, signers) in agent_store.all_agents() {
            println!("adding '{name}' signers to wallet map");
            for signer in signers.signers.iter() {
                wallet_map.insert(signer.address(), EthereumWallet::new(signer.clone()));
            }
        }

        let chain_id = rpc_client
            .get_chain_id()
            .await
            .map_err(|e| ContenderError::with_err(e, "failed to get chain id"))?;

        let mut nonces = HashMap::new();
        sync_nonces(&wallet_map, &mut nonces, &rpc_client).await?;

        let gas_limits = HashMap::new();

        let bundle_client = builder_rpc_url
            .as_ref()
            .map(|url| Arc::new(BundleClient::new(url.clone())));

        let msg_handle = Arc::new(TxActorHandle::new(120, db.clone(), rpc_client.clone()));
        let cancel_token = CancellationToken::new();

        Ok(Self {
            config,
            db: db.clone(),
            rpc_url: rpc_url.to_owned(),
            rpc_client,
            bundle_client,
            builder_rpc_url,
            rand_seed,
            wallet_map,
            agent_store,
            chain_id,
            nonces,
            gas_limits,
            msg_handle,
            tx_type,
            gas_price_percent_add: gas_price_percent_add.unwrap_or(0),
            pending_tx_timeout_secs,
            ctx: ExecutionContext {
                gas_price_adder: 0,
                block_time_secs,
                cancel_token,
            },
            auth_provider,
            prometheus,
        })
    }

    pub async fn sync_nonces(&mut self) -> Result<()> {
        sync_nonces(&self.wallet_map, &mut self.nonces, &self.rpc_client).await
    }

    pub async fn estimate_setup_cost(&self) -> Result<U256> {
        println!(
            "
================================================================================
================= running simulation to estimate setup cost ====================
================================================================================
"
        );
        // start anvil with dev accounts holding 1M eth
        let anvil = Anvil::new().args(["--balance", "1000000"]).spawn();
        let admin_signer = LocalSigner::from_str(
            "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
        )
        .expect("invalid signer");
        let admin_wallet = EthereumWallet::new(admin_signer.clone());
        // separate prometheus registry for simulations; anvil doesn't count!
        static PROM: OnceCell<prometheus::Registry> = OnceCell::const_new();
        static HIST: OnceCell<prometheus::HistogramVec> = OnceCell::const_new();
        let mut scenario = Self::new(
            self.config.to_owned(),
            self.db.clone(),
            self.rand_seed.to_owned(),
            TestScenarioParams {
                rpc_url: anvil.endpoint_url(),
                builder_rpc_url: None,
                signers: vec![admin_signer.to_owned()],
                agent_store: self.agent_store.clone(),
                tx_type: self.tx_type,
                gas_price_percent_add: Some(self.gas_price_percent_add), // will be 0 if not specified
                pending_tx_timeout_secs: self.pending_tx_timeout_secs,
            },
            None,
            (&PROM, &HIST),
        )
        .await?;

        let addresses = scenario
            .agent_store
            .all_signer_addresses()
            .into_iter()
            .collect::<Vec<Address>>();

        let fund_amount = if addresses.len() >= 999 {
            U256::from(999999 * ETH_TO_WEI / addresses.len() as u128)
        } else {
            U256::from(1000 * ETH_TO_WEI)
        };
        let start_balances: HashMap<Address, U256> =
            HashMap::from_iter(addresses.iter().map(|addr| (*addr, fund_amount)));

        let all_pools: Vec<String> = scenario
            .agent_store
            .all_agents()
            .map(|(name, _)| name.to_owned())
            .collect();
        for agent_name in all_pools {
            scenario
                .fund_agent_signers(agent_name, &admin_wallet, fund_amount)
                .await?;
        }

        scenario.deploy_contracts().await?;
        scenario.run_setup().await?;

        let mut total_cost = U256::ZERO;
        for (addr, start_balance) in &start_balances {
            let new_balance = scenario
                .rpc_client
                .get_balance(*addr)
                .await
                .map_err(|e| ContenderError::with_err(e, "failed to get balance"))?;
            if new_balance >= *start_balance {
                continue;
            }
            let cost = start_balance - new_balance;
            total_cost += cost;
        }

        println!(
            "
================================================================================
============================= simulation complete ==============================
================================================================================
"
        );

        Ok(total_cost)
    }

    /// Funds all signers in the agent with the given amount.
    /// Does not check if the agents are already funded.
    pub async fn fund_agent_signers(
        &mut self,
        agent_name: impl AsRef<str>,
        funder: &EthereumWallet,
        amount: U256,
    ) -> Result<()> {
        let addresses = self
            .agent_store
            .get_agent(&agent_name)
            .ok_or(ContenderError::SetupError(
                "agent not found",
                Some(agent_name.as_ref().to_owned()),
            ))?
            .all_addresses();
        let gas_price = self
            .rpc_client
            .get_gas_price()
            .await
            .map_err(|e| ContenderError::with_err(e, "failed to get gas price"))?;

        for addr in addresses {
            let tx_req = TransactionRequest::default()
                .with_from(funder.default_signer().address())
                .with_to(addr)
                .with_value(amount);
            let (tx_req, _) = self
                .prepare_tx_request(&tx_req, gas_price + GWEI_TO_WEI as u128)
                .await?;
            let signed_tx = tx_req
                .build(funder)
                .await
                .map_err(|e| ContenderError::with_err(e, "failed to build funding tx"))?;
            let pending = self
                .rpc_client
                .send_tx_envelope(AnyTxEnvelope::Ethereum(signed_tx))
                .await
                .map_err(|e| ContenderError::with_err(e, "failed to send funding tx"))?;
            println!(
                "funded account {}, tx: {}",
                addr.encode_hex(),
                pending.tx_hash()
            );
        }

        Ok(())
    }

    pub async fn deploy_contracts(&mut self) -> Result<()> {
        let pub_provider = &self.rpc_client;
        let gas_price = pub_provider
            .get_gas_price()
            .await
            .map_err(|e| ContenderError::with_err(e, "failed to get gas price"))?;
        let chain_id = pub_provider
            .get_chain_id()
            .await
            .map_err(|e| ContenderError::with_err(e, "failed to get chain id"))?;

        // we do everything in the callback so no need to actually capture the returned txs
        self.load_txs(PlanType::Create(|tx_req| {
            /* callback */
            // copy data/refs from self before spawning the task
            let db = self.db.clone();
            let from = tx_req.tx.from.to_owned().ok_or(ContenderError::SetupError(
                "failed to get 'from' address",
                None,
            ))?;
            let wallet_conf = self
                .wallet_map
                .get(&from)
                .unwrap_or_else(|| panic!("couldn't find wallet for 'from' address {from}"))
                .to_owned();
            let wallet = ProviderBuilder::new()
                .wallet(wallet_conf)
                .network::<AnyNetwork>()
                .on_http(self.rpc_url.to_owned());

            println!(
                "deploying contract: {:?}",
                tx_req.name.as_ref().unwrap_or(&"".to_string())
            );
            let rpc_url = self.rpc_url.to_owned();
            let tx_type = self.tx_type;
            let handle = tokio::task::spawn(async move {
                // estimate gas limit
                let gas_limit = wallet
                    .estimate_gas(WithOtherFields::new(tx_req.tx.to_owned()))
                    .await
                    .expect("failed to estimate gas");

                // inject missing fields into tx_req.tx
                let mut tx = tx_req.tx;
                complete_tx_request(&mut tx, tx_type, gas_price, gas_price / 10, gas_limit, chain_id);

                let res = wallet.send_transaction(WithOtherFields::new(tx)).await;
                if let Err(err) = res {
                    let err = err.to_string();
                    if err.to_lowercase().contains("already known") {
                        eprintln!("Transaction already known. You may be using the same seed (or private key) as another spammer. Try modifying seed with `-s`, or waiting if you set `-p`. JSON-RPC Error: {err:?}");
                    } else if err.to_lowercase().contains("insufficient funds") {
                        eprintln!(
                            "Insufficient funds for transaction (account: {from}). Try passing a funded private key with `-p`. JSON-RPC Error: {err:?}"
                        );
                    } else if err.to_lowercase().contains("replacement transaction underpriced") {
                        eprintln!("Replacement transaction underpriced. You may have to wait, or replace the currently-pending transactions manually. JSON-RPC Error: {err:?}");
                    } else {
                        eprintln!("failed to send tx: {err:?}");
                    }
                    return;
                }
                let res =
                    res.expect("this will never happen. If it does, I'm a terrible programmer.");
                let receipt = res.get_receipt().await.expect("failed to get receipt");
                println!(
                    "contract address: {}",
                    receipt.contract_address.unwrap_or_default()
                );
                db.insert_named_txs(
                    &[NamedTx::new(
                        tx_req.name.unwrap_or_default(),
                        receipt.transaction_hash,
                        receipt.contract_address,
                    )],
                    rpc_url.as_str(),
                )
                .expect("failed to insert tx into db");
            });
            Ok(Some(handle))
        }))
        .await?;

        self.sync_nonces().await?;

        Ok(())
    }

    pub async fn run_setup(&mut self) -> Result<()> {
        self.load_txs(PlanType::Setup(|tx_req| {
            /* callback */
            println!("{}", self.format_setup_log(&tx_req));

            // copy data/refs from self before spawning the task
            let from = tx_req.tx.from.as_ref().ok_or(ContenderError::SetupError(
                "failed to get 'from' address",
                None,
            ))?;
            let wallet = self
                .wallet_map
                .get(from)
                .ok_or(ContenderError::SetupError(
                    "couldn't find private key for address",
                    from.encode_hex().into(),
                ))?
                .to_owned();
            let db = self.db.clone();
            let rpc_url = self.rpc_url.clone();
            let tx_type = self.tx_type;

            let handle = tokio::task::spawn(async move {
                let wallet = ProviderBuilder::new()
                    .wallet(wallet)
                    .on_http(rpc_url.to_owned());

                let chain_id = wallet.get_chain_id().await.expect("failed to get chain id");
                let tx_label = tx_req
                    .name
                    .as_deref()
                    .or(tx_req.kind.as_deref())
                    .unwrap_or("")
                    .to_string();
                let gas_price = wallet.get_gas_price().await.unwrap_or_else(|_| {
                    panic!("failed to get gas price for setup step '{tx_label}'")
                });
                let gas_limit = if let Some(gas) = tx_req.tx.gas {
                    gas
                } else {
                    wallet
                        .estimate_gas(tx_req.tx.to_owned())
                        .await
                        .unwrap_or_else(|_| {
                            panic!("failed to estimate gas for setup step '{tx_label}'")
                        })
                };
                let mut tx = tx_req.tx;
                complete_tx_request(
                    &mut tx,
                    tx_type,
                    gas_price,
                    gas_price / 10,
                    gas_limit,
                    chain_id,
                );

                // wallet will assign nonce before sending
                let res = wallet
                    .send_transaction(tx)
                    .await
                    .unwrap_or_else(|_| panic!("failed to send setup tx '{tx_label}'"));

                // get receipt using provider (not wallet) to allow any receipt type (support non-eth chains)
                let receipt = res
                    .get_receipt()
                    .await
                    .unwrap_or_else(|_| panic!("failed to get receipt for tx '{tx_label}'"));

                if let Some(name) = tx_req.name {
                    db.insert_named_txs(
                        &[NamedTx::new(
                            name,
                            receipt.transaction_hash,
                            receipt.contract_address,
                        )],
                        rpc_url.as_str(),
                    )
                    .expect("failed to insert tx into db");
                }
            });
            Ok(Some(handle))
        }))
        .await?;

        self.sync_nonces().await?;

        Ok(())
    }

    pub async fn prepare_tx_request(
        &mut self,
        tx_req: &TransactionRequest,
        gas_price: u128,
    ) -> Result<(TransactionRequest, EthereumWallet)> {
        let from = tx_req.from.ok_or(ContenderError::SetupError(
            "missing 'from' address in tx request",
            None,
        ))?;
        let nonce = self
            .nonces
            .get(&from)
            .ok_or(ContenderError::SetupError(
                "missing nonce for 'from' address",
                Some(from.to_string()),
            ))?
            .to_owned();
        self.nonces.insert(from.to_owned(), nonce + 1);

        let key = keccak256(tx_req.input.input.to_owned().unwrap_or_default());

        if let std::collections::hash_map::Entry::Vacant(_) = self.gas_limits.entry(key) {
            let gas_limit = if let Some(gas) = tx_req.gas {
                gas
            } else {
                self.rpc_client
                    .estimate_gas(WithOtherFields::new(tx_req.to_owned()))
                    .await
                    .map_err(|e| ContenderError::with_err(e, "failed to estimate gas for tx"))?
            };
            self.gas_limits.insert(key, gas_limit);
        }
        let gas_limit = self
            .gas_limits
            .get(&key)
            .ok_or(ContenderError::SetupError(
                "failed to lookup gas limit",
                None,
            ))?
            .to_owned();
        let signer = self
            .wallet_map
            .get(&from)
            .ok_or(ContenderError::SetupError(
                "failed to get signer from scenario wallet_map",
                None,
            ))?
            .to_owned();

        let mut full_tx = tx_req.to_owned().with_nonce(nonce);
        complete_tx_request(
            &mut full_tx,
            self.tx_type,
            gas_price,
            gas_price / 10,
            gas_limit,
            self.chain_id,
        );

        Ok((full_tx, signer))
    }

    pub async fn prepare_spam(
        &mut self,
        tx_requests: &[ExecutionRequest],
    ) -> Result<Vec<ExecutionPayload>> {
        let gas_price = self
            .rpc_client
            .get_gas_price()
            .await
            .map_err(|e| ContenderError::with_err(e, "failed to get gas price"))?;
        let gas_price = gas_price + ((gas_price * self.gas_price_percent_add as u128) / 100);
        let gas_price = if self.ctx.gas_price_adder < 0 {
            gas_price - self.ctx.gas_price_adder.unsigned_abs()
        } else {
            gas_price + self.ctx.gas_price_adder as u128
        };
        let mut payloads = vec![];
        println!("preparing {} spam payloads", tx_requests.len());
        for tx in tx_requests {
            let payload = match tx {
                ExecutionRequest::Bundle(reqs) => {
                    if self.bundle_client.is_none() {
                        return Err(ContenderError::SpamError(
                            "Bundle client not found. Specify a builder url to send bundles.",
                            None,
                        ));
                    }

                    // prepare each tx in the bundle (increment nonce, set gas price, etc)
                    let mut bundle_txs = vec![];

                    for req in reqs {
                        let (tx_req, signer) = self
                            .prepare_tx_request(&req.tx, gas_price)
                            .await
                            .map_err(|e| ContenderError::with_err(e, "failed to prepare tx"))?;

                        println!("bundle tx from {:?}", tx_req.from);
                        // sign tx
                        let tx_envelope = tx_req.build(&signer).await.map_err(|e| {
                            ContenderError::with_err(e, "bad request: failed to build tx")
                        })?;

                        bundle_txs.push(tx_envelope);
                    }
                    ExecutionPayload::SignedTxBundle(bundle_txs, reqs.to_owned())
                }
                ExecutionRequest::Tx(req) => {
                    let (tx_req, signer) = self
                        .prepare_tx_request(&req.tx, gas_price)
                        .await
                        .map_err(|e| ContenderError::with_err(e, "failed to prepare tx"))?;
                    let mut new_req = req.to_owned();
                    new_req.tx = tx_req.to_owned();

                    // sign tx
                    let tx_envelope = tx_req.build(&signer).await.map_err(|e| {
                        ContenderError::with_err(e, "bad request: failed to build tx")
                    })?;

                    // log tx details
                    let priority_fee = new_req
                        .tx
                        .max_priority_fee_per_gas
                        .map(|f| format!(" priority_fee: {f},"))
                        .unwrap_or_default();
                    println!(
                        "prepared tx: {}, from: {}, to: {:?}, input: {}, value={}, gas_limit: {}, gas_price: {},{priority_fee} nonce={}",
                        tx_envelope.tx_hash(),
                        new_req.tx.from.map(|s| s.encode_hex()).unwrap_or_default(),
                        tx_envelope.to(),
                        new_req.tx
                            .input
                            .input
                            .as_ref()
                            .map(|s| s.encode_hex())
                            .unwrap_or_default(),
                        new_req.tx
                            .value
                            .map(|s| s.to_string())
                            .unwrap_or("0".to_owned()),
                        new_req.tx
                            .gas
                            .map(|g| g.to_string())
                            .unwrap_or("N/A".to_owned()),
                        new_req.tx.gas_price.unwrap_or(new_req.tx.max_fee_per_gas.unwrap_or(0)),
                        new_req.tx.nonce.map(|n| n.to_string()).unwrap_or("N/A".to_owned())
                    );

                    ExecutionPayload::SignedTx(Box::new(tx_envelope), new_req)
                }
            };
            payloads.push(payload);
        }
        println!("prepared {} payloads", payloads.len());
        Ok(payloads)
    }

    /// Send one batch of spam txs evenly over one second.
    async fn execute_spam(
        &mut self,
        trigger: SpamTrigger,
        payloads: Vec<ExecutionPayload>,
        callback_handler: Arc<impl OnTxSent + OnBatchSent + Send + Sync + 'static>,
        context_handler: SpamContextHandler,
    ) -> Result<Vec<tokio::task::JoinHandle<()>>> {
        // sort payloads by nonce
        let mut payloads = payloads;
        payloads.sort_by(|a, b| {
            let a_nonce = match a {
                ExecutionPayload::SignedTx(_, req) => req.tx.nonce,
                ExecutionPayload::SignedTxBundle(_, reqs) => reqs[0].tx.nonce,
            };
            let b_nonce = match b {
                ExecutionPayload::SignedTx(_, req) => req.tx.nonce,
                ExecutionPayload::SignedTxBundle(_, reqs) => reqs[0].tx.nonce,
            };
            a_nonce.cmp(&b_nonce)
        });

        let num_payloads = payloads.len();

        let mut tasks: Vec<tokio::task::JoinHandle<()>> = vec![];

        // spawn at regular interval
        let micros_per_task = 1_000_000 / num_payloads.max(1) as u64;

        // takes gas to add to the gas price for the next batch (if needed)
        let gas_sender = Arc::new(context_handler.add_gas);
        // counts number of txs that were sent successfully
        let success_sender = Arc::new(context_handler.success_send_tx);
        for payload in payloads {
            let rpc_client = self.rpc_client.clone();
            let bundle_client = self.bundle_client.clone();
            let callback_handler = callback_handler.clone();
            let tx_handler = self.msg_handle.clone();
            let gas_sender = gas_sender.clone();
            let success_sender = success_sender.clone();
            let cancel_token = self.ctx.cancel_token.clone();

            std::thread::sleep(Duration::from_micros(micros_per_task));
            tasks.push(tokio::task::spawn(async move {
                let mut extra = HashMap::new();
                let start_timestamp = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .expect("time went backwards")
                    .as_millis();
                extra.insert("start_timestamp".to_owned(), start_timestamp.to_string());
                let handles = match payload {
                    ExecutionPayload::SignedTx(signed_tx, req) => {
                        let tx_hash = signed_tx.tx_hash().to_owned();
                        let res = rpc_client
                            .send_tx_envelope(AnyTxEnvelope::Ethereum(*signed_tx))
                            .await;

                        match res {
                            Ok(res) => {
                                let maybe_handle = callback_handler.on_tx_sent(
                                    res.into_inner(),
                                    &req,
                                    Some(extra),
                                    Some(tx_handler.clone()),
                                );

                                tokio::select! {
                                    _ = cancel_token.cancelled() => {
                                        return;
                                    }
                                    _ = success_sender
                                    .send(()) => {
                                        // wait for the task to finish
                                    }
                                };

                                vec![maybe_handle]
                            }
                            Err(e) => {
                                if let Some(err) = e.as_error_resp() {
                                    if err
                                        .message
                                        .to_lowercase()
                                        .contains("replacement transaction underpriced")
                                    {
                                        // send the current gas price / 10 to increase it by 10% for the next batch
                                        gas_sender
                                            .send(
                                                req.tx.max_fee_per_gas.unwrap_or(
                                                    req.tx.gas_price.unwrap_or(1_000_000_000),
                                                ) / 10,
                                            )
                                            .await
                                            .expect("failed to send gas update signal");
                                    }

                                    // include errored txs in the cache; user may want to retry them
                                    // if they are due to nonce issues, this will fail, but if they do land somehow,
                                    // they will be awaited in the post-spam loop
                                    println!("error from tx {tx_hash}: {err:?}");
                                    extra.insert("error".to_owned(), err.to_string());
                                    vec![callback_handler.on_tx_sent(
                                        PendingTransactionConfig::new(tx_hash),
                                        &req,
                                        Some(extra),
                                        Some(tx_handler.clone()),
                                    )]
                                } else {
                                    // ignore errors that can't be decoded
                                    println!("ignoring tx response, could not decode error: {e:?}");
                                    vec![]
                                }
                            }
                        }
                    }
                    ExecutionPayload::SignedTxBundle(signed_txs, reqs) => {
                        let mut bundle_txs = vec![];
                        for tx in &signed_txs {
                            let mut raw_tx = vec![];
                            tx.encode_2718(&mut raw_tx);
                            bundle_txs.push(raw_tx);
                        }
                        let block_num = match trigger {
                            SpamTrigger::BlockNumber(n) => n,
                            SpamTrigger::BlockHash(h) => {
                                let block = rpc_client
                                    .get_block_by_hash(h)
                                    .await
                                    .expect("failed to get block")
                                    .expect("block not found");
                                block.header.number
                            }
                            _ => rpc_client
                                .get_block_number()
                                .await
                                .expect("failed to get block number"),
                        };
                        let rpc_bundle = new_basic_bundle(
                            bundle_txs.into_iter().map(|b| b.into()).collect(),
                            block_num,
                        );
                        if let Some(bundle_client) = bundle_client {
                            println!("spamming bundle: {rpc_bundle:?}");
                            for i in 1..4 {
                                let mut rpc_bundle = rpc_bundle.clone();
                                rpc_bundle.block_number = block_num + i as u64;

                                let res = bundle_client.send_bundle(rpc_bundle).await;
                                if let Err(e) = res {
                                    println!("failed to send bundle: {e:?}");
                                }
                            }
                        } else {
                            panic!("bundle client not found");
                        }

                        let mut tx_handles = vec![];
                        for (tx, req) in signed_txs.into_iter().zip(reqs) {
                            let maybe_handle = callback_handler.on_tx_sent(
                                PendingTransactionConfig::new(*tx.tx_hash()),
                                &req,
                                Some(extra.clone()),
                                Some(tx_handler.clone()),
                            );
                            tx_handles.push(maybe_handle);
                        }
                        tx_handles
                    }
                };

                for handle in handles.into_iter().flatten() {
                    tokio::select! {
                        _ = cancel_token.cancelled() => {
                            println!("cancelled spammer task");
                            return;
                        }
                        _ = handle => {
                            // wait for the task to finish
                        }
                    }
                }
            }));
        }

        Ok(tasks)
    }

    /// Send spam batches until the cursor is depleted.
    pub async fn execute_spammer<F: OnTxSent + OnBatchSent + Send + Sync + 'static>(
        &mut self,
        cursor: &mut futures::stream::Take<Pin<Box<dyn Stream<Item = SpamTrigger> + Send>>>,
        tx_req_chunks: &[Vec<ExecutionRequest>],
        sent_tx_callback: Arc<F>,
    ) -> Result<()> {
        let mut tick = 0;
        while let Some(trigger) = cursor.next().await {
            let trigger = trigger.to_owned();
            // assign from addrs, nonces, and gas prices for this chunk of tx requests
            let payloads = self.prepare_spam(&tx_req_chunks[tick]).await?;
            let num_payloads = payloads.len();

            // initialize async context handlers
            let (success_sender, mut success_receiver) = tokio::sync::mpsc::channel(num_payloads);
            let (add_gas_sender, mut add_gas_receiver) = tokio::sync::mpsc::channel(num_payloads);
            let context = SpamContextHandler {
                success_send_tx: success_sender,
                add_gas: add_gas_sender,
            };

            // send this batch of spam txs
            let spam_tasks = self
                .execute_spam(trigger, payloads, sent_tx_callback.clone(), context)
                .await?;
            let mut num_tasks = spam_tasks.len();

            // wait for spam txs to finish sending
            for task in spam_tasks {
                tokio::select! {
                    res = task => {
                        if let Err(e) = res {
                            println!("spam task failed: {e:?}");
                            num_tasks -= 1;
                        }
                    },
                    _ = self.ctx.cancel_token.cancelled() => {
                        break;
                    }
                }
            }

            // wait for the on_batch_sent callback to finish
            if let Some(task) = sent_tx_callback.on_batch_sent() {
                task.await
                    .map_err(|e| ContenderError::with_err(e, "on_batch_sent callback failed"))?;
            }

            println!("[{tick}] executed {num_tasks} spam tasks");

            // increase gas price if needed
            add_gas_receiver.close();
            let starting_gas_adder = self.ctx.gas_price_adder;
            while let Some(gas) = add_gas_receiver.recv().await {
                if self.ctx.gas_price_adder >= gas as i128 + starting_gas_adder {
                    continue;
                }
                println!("incrementing gas price by {gas}");
                self.ctx.add_to_gas_price(gas as i128);
            }

            // decrease gas price if all txs were sent successfully
            success_receiver.close();
            let mut success_count = 0;
            while success_receiver.recv().await.is_some() {
                success_count += 1;
            }
            if success_count == num_payloads {
                println!("all spam txs sent successfully");
                if self.ctx.gas_price_adder > 0 {
                    // remove 10% of the gas price adder
                    self.ctx.add_to_gas_price(self.ctx.gas_price_adder / -10);
                }
            } else {
                println!(
                    "some spam txs failed to send: {} / {}",
                    num_payloads - success_count,
                    num_payloads
                );
            }

            // increment tick to get next chunk of txs
            tick += 1;
        }

        Ok(())
    }

    fn format_setup_log(&self, tx_req: &NamedTxRequest) -> String {
        let to_address = tx_req.tx.to.unwrap_or_default();
        let to_address = to_address.to();

        // lookup name of contract if it exists
        let to_name = to_address.map(|a| {
            let named_tx = self.db.get_named_tx_by_address(a);
            named_tx
                .map(|t| t.map(|tt| tt.name).unwrap_or_default())
                .unwrap_or_default()
        });

        format!(
            "running setup: from={} to={} {}",
            tx_req
                .tx
                .from
                .as_ref()
                .map(|a| a.encode_hex())
                .unwrap_or_default(),
            if let Some(to) = to_name {
                to
            } else {
                to_address.map(|a| a.encode_hex()).unwrap_or_default()
            },
            if let Some(kind) = &tx_req.kind {
                format!("kind={kind}")
            } else {
                "".to_string()
            },
        )
    }

    /// Returns the maximum cost of a single spam transaction by creating a new scenario
    /// and running estimateGas calls to estimate the cost of the spam transactions.
    pub async fn get_max_spam_cost(&self, user_signers: &[PrivateKeySigner]) -> Result<U256> {
        // separate prometheus registry for simulations; anvil doesn't count!
        static PROM: OnceCell<prometheus::Registry> = OnceCell::const_new();
        static HIST: OnceCell<prometheus::HistogramVec> = OnceCell::const_new();
        let mut scenario = TestScenario::new(
            self.config.to_owned(),
            self.db.clone(),
            self.rand_seed.clone(),
            TestScenarioParams {
                rpc_url: self.rpc_url.clone(),
                builder_rpc_url: self.builder_rpc_url.clone(),
                signers: user_signers.to_owned(),
                agent_store: self.agent_store.clone(),
                tx_type: self.tx_type,
                gas_price_percent_add: Some(self.gas_price_percent_add),
                pending_tx_timeout_secs: self.pending_tx_timeout_secs,
            },
            None,
            (&PROM, &HIST),
        )
        .await?;

        // load a sample of each spam tx from the scenario
        let txs = scenario
            .load_txs(PlanType::Spam(
                scenario
                    .config
                    .get_spam_steps()
                    .map(|s| s.len()) // take the number of spam txs from the testfile
                    .unwrap_or(0) as u64,
                |_named_req| {
                    // we can look at the named request here if needed
                    Ok(None)
                },
            ))
            .await?;
        let sample_txs = scenario
            .prepare_spam(&txs)
            .await?
            .iter()
            .map(|ex_payload| match ex_payload {
                ExecutionPayload::SignedTx(_envelope, tx_req) => vec![tx_req.to_owned()],
                ExecutionPayload::SignedTxBundle(_envelopes, tx_reqs) => tx_reqs
                    .iter()
                    .map(|tx| Box::new(tx.to_owned()))
                    .collect::<Vec<_>>(),
            })
            .collect::<Vec<_>>()
            .concat();

        let gas_price = scenario
            .rpc_client
            .get_gas_price()
            .await
            .map_err(|e| ContenderError::with_err(e, "failed to get gas price"))?;

        // get gas limit for each tx
        let mut prepared_sample_txs = vec![];
        for tx in sample_txs {
            let tx_req = tx.tx;
            let (prepared_req, _signer) = scenario.prepare_tx_request(&tx_req, gas_price).await?;
            prepared_sample_txs.push(prepared_req);
        }

        // get the highest gas cost of all spam txs
        let highest_gas_cost = prepared_sample_txs
            .iter()
            .map(|tx| {
                let mut gas_price = tx.max_fee_per_gas.unwrap_or(tx.gas_price.unwrap_or(0));
                if let Some(priority_fee) = tx.max_priority_fee_per_gas {
                    gas_price += priority_fee;
                }
                U256::from(gas_price * tx.gas.unwrap_or(0) as u128) + tx.value.unwrap_or(U256::ZERO)
            })
            .max()
            .ok_or(ContenderError::SpamError(
                "failed to get max gas cost for spam txs",
                None,
            ))?;

        // we assume the highest possible cost to minimize the chances of running out of ETH mid-test
        Ok(highest_gas_cost)
    }

    pub async fn get_spam_tx_chunks(
        &self,
        txs_per_period: u64,
        num_periods: u64,
    ) -> Result<Vec<Vec<ExecutionRequest>>> {
        let tx_requests = self
            .load_txs(crate::generator::PlanType::Spam(
                txs_per_period * num_periods,
                |_named_req| Ok(None), // we can look at the named request here if needed
            ))
            .await?;
        Ok(tx_requests
            .chunks(txs_per_period as usize)
            .map(|chunk| chunk.to_vec())
            .collect::<_>())
    }

    pub async fn flush_tx_cache(&self, block_start: u64, run_id: u64) -> Result<()> {
        let mut block_counter = 0;
        // the number of blocks to check for stalled txs
        let block_timeout = ((self.pending_tx_timeout_secs / self.ctx.block_time_secs) + 1)
            // must be at least 2 blocks because otherwise we have nothing to compare
            .max(2);
        let mut cache_size_queue = vec![];
        cache_size_queue.resize(block_timeout as usize, 1);
        loop {
            let pending_txs = self
                .msg_handle
                .flush_cache(run_id, block_start + block_counter as u64)
                .await
                .map_err(|e| ContenderError::with_err(e.deref(), "failed to flush cache"))?;
            cache_size_queue.rotate_right(1);
            cache_size_queue[0] = pending_txs.len();

            if pending_txs.is_empty() {
                break;
            }

            let current_timestamp = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .expect("time went backwards")
                .as_millis();

            // remove cached txs if the size hasn't changed for the last N blocks
            if cache_size_queue
                .iter()
                .all(|&size| size == cache_size_queue[0])
            {
                println!(
                            "Cache size has not changed for the last {block_timeout} blocks. Removing stalled txs...",
                        );
                for tx in &pending_txs {
                    // only remove txs that have been waiting for > T seconds
                    if current_timestamp
                        > (tx.start_timestamp + (self.pending_tx_timeout_secs * 1000)) as u128
                    {
                        self.msg_handle
                            .remove_cached_tx(tx.tx_hash)
                            .await
                            .map_err(|e| {
                                ContenderError::with_err(
                                    e.deref(),
                                    "failed to remove tx from cache",
                                )
                            })?;
                    }
                }
            }

            block_counter += 1;
        }

        Ok(())
    }

    pub async fn dump_tx_cache(&self, run_id: u64) -> Result<()> {
        println!("dumping tx cache...");

        let failed_txs = self
            .msg_handle
            .dump_cache(run_id)
            .await
            .map_err(|e| ContenderError::with_err(e.deref(), "failed to dump cache"))?;
        if !failed_txs.is_empty() {
            println!(
                "Failed to collect receipts for {} txs. Any valid txs sent may still land.",
                failed_txs.len()
            );
        }

        Ok(())
    }

    /// Collects latency metrics from the prometheus registry.
    /// Returns a map of RPC method names to a vector of latency buckets which represent (upper_bound_secs, cumulative_count).
    pub fn collect_latency_metrics(&self) -> BTreeMap<String, Vec<Bucket>> {
        let registry = self.prometheus.0.get();
        let mut latency_map = BTreeMap::new();
        if let Some(registry) = registry {
            let metric_families = registry.gather();

            for mf in &metric_families {
                if mf.name() == RPC_REQUEST_LATENCY_ID {
                    for m in mf.get_metric() {
                        let mut latencies: Vec<Bucket> = vec![];
                        if m.label.is_empty() {
                            continue;
                        }
                        let label = m.label.first().expect("label");
                        if label.name() != "rpc_method" {
                            continue;
                        }
                        let hist = m.get_histogram();
                        for bucket in &hist.bucket {
                            if bucket.cumulative_count.is_none() {
                                continue;
                            }
                            let upper_bound = bucket.upper_bound();
                            let cumulative_count =
                                bucket.cumulative_count.expect("cumulative_count");

                            latencies.push((upper_bound, cumulative_count).into());
                        }
                        latency_map.insert(label.value().to_string(), latencies);
                    }
                }
            }
        }
        latency_map
    }
}

async fn sync_nonces(
    wallet_map: &HashMap<Address, EthereumWallet>,
    nonces: &mut HashMap<Address, u64>,
    rpc_client: &AnyProvider,
) -> Result<()> {
    let all_addrs = wallet_map.keys().copied().collect::<Vec<Address>>();
    let mut tasks = vec![];
    let (sender, mut receiver) = tokio::sync::mpsc::channel::<(Address, u64)>(all_addrs.len() + 1);
    for addr in all_addrs {
        let send = sender.clone();
        let rpc_client = Arc::new(rpc_client.clone());
        tasks.push(tokio::task::spawn(async move {
            let nonce = rpc_client
                .get_transaction_count(addr)
                .await
                .map_err(|e| ContenderError::with_err(e, "failed to retrieve nonce from RPC"))?;
            send.send((addr, nonce))
                .await
                .map_err(|e| ContenderError::with_err(e, "(mpsc) failed to send nonce"))?;
            Ok::<_, ContenderError>(())
        }));
    }

    for task in tasks {
        if let Err(e) = task.await {
            eprintln!("failed to sync nonce: {e:?}");
        }
    }
    receiver.close();

    println!("waiting for nonces to sync...");
    while let Some((addr, nonce)) = receiver.recv().await {
        nonces.insert(addr, nonce);
    }

    Ok(())
}

impl<D, S, P> Generator<String, D, P> for TestScenario<D, S, P>
where
    D: DbOps + Send + Sync,
    S: Seeder,
    P: PlanConfig<String> + Templater<String> + Send + Sync,
{
    fn get_db(&self) -> &D {
        self.db.as_ref()
    }

    fn get_templater(&self) -> &P {
        &self.config
    }

    fn get_plan_conf(&self) -> &impl PlanConfig<String> {
        &self.config
    }

    fn get_fuzz_seeder(&self) -> &impl Seeder {
        &self.rand_seed
    }

    fn get_agent_store(&self) -> &AgentStore {
        &self.agent_store
    }

    fn get_rpc_url(&self) -> String {
        self.rpc_url.to_string()
    }
}

struct SpamContextHandler {
    add_gas: tokio::sync::mpsc::Sender<u128>,
    success_send_tx: tokio::sync::mpsc::Sender<()>,
}

#[cfg(test)]
pub mod tests {
    use crate::agent_controller::{AgentStore, SignerStore};
    use crate::db::MockDb;
    use crate::generator::named_txs::ExecutionRequest;
    use crate::generator::templater::Templater;
    use crate::generator::types::{
        CreateDefinition, FunctionCallDefinition, FuzzParam, SpamRequest,
    };
    use crate::generator::{types::PlanType, util::test::spawn_anvil, RandSeed};
    use crate::generator::{Generator, PlanConfig};
    use crate::spammer::util::test::get_test_signers;
    use crate::test_scenario::TestScenario;
    use crate::Result;
    use alloy::consensus::constants::GWEI_TO_WEI;
    use alloy::hex::ToHexExt;
    use alloy::node_bindings::AnvilInstance;
    use alloy::primitives::{Address, U256};
    use std::collections::HashMap;
    use tokio::sync::OnceCell;

    use super::TestScenarioParams;

    // separate prometheus registry for simulations; anvil doesn't count!
    static PROM: OnceCell<prometheus::Registry> = OnceCell::const_new();
    static HIST: OnceCell<prometheus::HistogramVec> = OnceCell::const_new();

    #[derive(Clone)]
    pub struct MockConfig;

    pub const COUNTER_BYTECODE: &str =
        "0x608060405234801561001057600080fd5b5060f78061001f6000396000f3fe6080604052348015600f57600080fd5b5060043610603c5760003560e01c80633fb5c1cb1460415780638381f58a146053578063d09de08a14606d575b600080fd5b6051604c3660046083565b600055565b005b605b60005481565b60405190815260200160405180910390f35b6051600080549080607c83609b565b9190505550565b600060208284031215609457600080fd5b5035919050565b60006001820160ba57634e487b7160e01b600052601160045260246000fd5b506001019056fea264697066735822122010f3077836fb83a22ad708a23102f2b487523767e1afef5a93c614619001648b64736f6c63430008170033";
    pub const UNI_V2_FACTORY_BYTECODE: &str = "0x608060405234801561001057600080fd5b506040516136863803806136868339818101604052602081101561003357600080fd5b5051600180546001600160a01b0319166001600160a01b03909216919091179055613623806100636000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063a2e74af61161005b578063a2e74af6146100fd578063c9c6539614610132578063e6a439051461016d578063f46901ed146101a857610088565b8063017e7e581461008d578063094b7415146100be5780631e3dd18b146100c6578063574f2ba3146100e3575b600080fd5b6100956101db565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b6100956101f7565b610095600480360360208110156100dc57600080fd5b5035610213565b6100eb610247565b60408051918252519081900360200190f35b6101306004803603602081101561011357600080fd5b503573ffffffffffffffffffffffffffffffffffffffff1661024d565b005b6100956004803603604081101561014857600080fd5b5073ffffffffffffffffffffffffffffffffffffffff8135811691602001351661031a565b6100956004803603604081101561018357600080fd5b5073ffffffffffffffffffffffffffffffffffffffff8135811691602001351661076d565b610130600480360360208110156101be57600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166107a0565b60005473ffffffffffffffffffffffffffffffffffffffff1681565b60015473ffffffffffffffffffffffffffffffffffffffff1681565b6003818154811061022057fe5b60009182526020909120015473ffffffffffffffffffffffffffffffffffffffff16905081565b60035490565b60015473ffffffffffffffffffffffffffffffffffffffff1633146102d357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f556e697377617056323a20464f5242494444454e000000000000000000000000604482015290519081900360640190fd5b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60008173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156103b757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f556e697377617056323a204944454e544943414c5f4144445245535345530000604482015290519081900360640190fd5b6000808373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16106103f45783856103f7565b84845b909250905073ffffffffffffffffffffffffffffffffffffffff821661047e57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601760248201527f556e697377617056323a205a45524f5f41444452455353000000000000000000604482015290519081900360640190fd5b73ffffffffffffffffffffffffffffffffffffffff82811660009081526002602090815260408083208585168452909152902054161561051f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601660248201527f556e697377617056323a20504149525f45584953545300000000000000000000604482015290519081900360640190fd5b6060604051806020016105319061086d565b6020820181038252601f19601f82011660405250905060008383604051602001808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1660601b81526014018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1660601b815260140192505050604051602081830303815290604052805190602001209050808251602084016000f5604080517f485cc95500000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8781166004830152868116602483015291519297509087169163485cc9559160448082019260009290919082900301818387803b15801561065e57600080fd5b505af1158015610672573d6000803e3d6000fd5b5050505073ffffffffffffffffffffffffffffffffffffffff84811660008181526002602081815260408084208987168086529083528185208054978d167fffffffffffffffffffffffff000000000000000000000000000000000000000098891681179091559383528185208686528352818520805488168517905560038054600181018255958190527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b90950180549097168417909655925483519283529082015281517f0d3648bd0f6ba80134a33ba9275ac585d9d315f0ad8355cddefde31afa28d0e9929181900390910190a35050505092915050565b600260209081526000928352604080842090915290825290205473ffffffffffffffffffffffffffffffffffffffff1681565b60015473ffffffffffffffffffffffffffffffffffffffff16331461082657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f556e697377617056323a20464f5242494444454e000000000000000000000000604482015290519081900360640190fd5b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b612d748061087b8339019056fe60806040526001600c5534801561001557600080fd5b506040514690806052612d228239604080519182900360520182208282018252600a8352692ab734b9bbb0b8102b1960b11b6020938401528151808301835260018152603160f81b908401528151808401919091527fbfcc8ef98ffbf7b6c3fec7bf5185b566b9863e35a9d83acd49ad6824b5969738818301527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6606082015260808101949094523060a0808601919091528151808603909101815260c09094019052825192019190912060035550600580546001600160a01b03191633179055612c1d806101056000396000f3fe608060405234801561001057600080fd5b50600436106101b95760003560e01c80636a627842116100f9578063ba9a7a5611610097578063d21220a711610071578063d21220a7146105da578063d505accf146105e2578063dd62ed3e14610640578063fff6cae91461067b576101b9565b8063ba9a7a5614610597578063bc25cf771461059f578063c45a0155146105d2576101b9565b80637ecebe00116100d35780637ecebe00146104d757806389afcb441461050a57806395d89b4114610556578063a9059cbb1461055e576101b9565b80636a6278421461046957806370a082311461049c5780637464fc3d146104cf576101b9565b806323b872dd116101665780633644e515116101405780633644e51514610416578063485cc9551461041e5780635909c0d5146104595780635a3d549314610461576101b9565b806323b872dd146103ad57806330adf81f146103f0578063313ce567146103f8576101b9565b8063095ea7b311610197578063095ea7b3146103155780630dfe16811461036257806318160ddd14610393576101b9565b8063022c0d9f146101be57806306fdde03146102595780630902f1ac146102d6575b600080fd5b610257600480360360808110156101d457600080fd5b81359160208101359173ffffffffffffffffffffffffffffffffffffffff604083013516919081019060808101606082013564010000000081111561021857600080fd5b82018360208201111561022a57600080fd5b8035906020019184600183028401116401000000008311171561024c57600080fd5b509092509050610683565b005b610261610d57565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561029b578181015183820152602001610283565b50505050905090810190601f1680156102c85780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6102de610d90565b604080516dffffffffffffffffffffffffffff948516815292909316602083015263ffffffff168183015290519081900360600190f35b61034e6004803603604081101561032b57600080fd5b5073ffffffffffffffffffffffffffffffffffffffff8135169060200135610de5565b604080519115158252519081900360200190f35b61036a610dfc565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b61039b610e18565b60408051918252519081900360200190f35b61034e600480360360608110156103c357600080fd5b5073ffffffffffffffffffffffffffffffffffffffff813581169160208101359091169060400135610e1e565b61039b610efd565b610400610f21565b6040805160ff9092168252519081900360200190f35b61039b610f26565b6102576004803603604081101561043457600080fd5b5073ffffffffffffffffffffffffffffffffffffffff81358116916020013516610f2c565b61039b611005565b61039b61100b565b61039b6004803603602081101561047f57600080fd5b503573ffffffffffffffffffffffffffffffffffffffff16611011565b61039b600480360360208110156104b257600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166113cb565b61039b6113dd565b61039b600480360360208110156104ed57600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166113e3565b61053d6004803603602081101561052057600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166113f5565b6040805192835260208301919091528051918290030190f35b610261611892565b61034e6004803603604081101561057457600080fd5b5073ffffffffffffffffffffffffffffffffffffffff81351690602001356118cb565b61039b6118d8565b610257600480360360208110156105b557600080fd5b503573ffffffffffffffffffffffffffffffffffffffff166118de565b61036a611ad4565b61036a611af0565b610257600480360360e08110156105f857600080fd5b5073ffffffffffffffffffffffffffffffffffffffff813581169160208101359091169060408101359060608101359060ff6080820135169060a08101359060c00135611b0c565b61039b6004803603604081101561065657600080fd5b5073ffffffffffffffffffffffffffffffffffffffff81358116916020013516611dd8565b610257611df5565b600c546001146106f457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c55841515806107075750600084115b61075c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526025815260200180612b2f6025913960400191505060405180910390fd5b600080610767610d90565b5091509150816dffffffffffffffffffffffffffff168710801561079a5750806dffffffffffffffffffffffffffff1686105b6107ef576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526021815260200180612b786021913960400191505060405180910390fd5b600654600754600091829173ffffffffffffffffffffffffffffffffffffffff91821691908116908916821480159061085457508073ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff1614155b6108bf57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f556e697377617056323a20494e56414c49445f544f0000000000000000000000604482015290519081900360640190fd5b8a156108d0576108d0828a8d611fdb565b89156108e1576108e1818a8c611fdb565b86156109c3578873ffffffffffffffffffffffffffffffffffffffff166310d1e85c338d8d8c8c6040518663ffffffff1660e01b8152600401808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f8201169050808301925050509650505050505050600060405180830381600087803b1580156109aa57600080fd5b505af11580156109be573d6000803e3d6000fd5b505050505b604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905173ffffffffffffffffffffffffffffffffffffffff8416916370a08231916024808301926020929190829003018186803b158015610a2f57600080fd5b505afa158015610a43573d6000803e3d6000fd5b505050506040513d6020811015610a5957600080fd5b5051604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905191955073ffffffffffffffffffffffffffffffffffffffff8316916370a0823191602480820192602092909190829003018186803b158015610acb57600080fd5b505afa158015610adf573d6000803e3d6000fd5b505050506040513d6020811015610af557600080fd5b5051925060009150506dffffffffffffffffffffffffffff85168a90038311610b1f576000610b35565b89856dffffffffffffffffffffffffffff160383035b9050600089856dffffffffffffffffffffffffffff16038311610b59576000610b6f565b89856dffffffffffffffffffffffffffff160383035b90506000821180610b805750600081115b610bd5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526024815260200180612b546024913960400191505060405180910390fd5b6000610c09610beb84600363ffffffff6121e816565b610bfd876103e863ffffffff6121e816565b9063ffffffff61226e16565b90506000610c21610beb84600363ffffffff6121e816565b9050610c59620f4240610c4d6dffffffffffffffffffffffffffff8b8116908b1663ffffffff6121e816565b9063ffffffff6121e816565b610c69838363ffffffff6121e816565b1015610cd657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f556e697377617056323a204b0000000000000000000000000000000000000000604482015290519081900360640190fd5b5050610ce4848488886122e0565b60408051838152602081018390528082018d9052606081018c9052905173ffffffffffffffffffffffffffffffffffffffff8b169133917fd78ad95fa46c994b6551d0da85fc275fe613ce37657fb8d5e3d130840159d8229181900360800190a350506001600c55505050505050505050565b6040518060400160405280600a81526020017f556e69737761702056320000000000000000000000000000000000000000000081525081565b6008546dffffffffffffffffffffffffffff808216926e0100000000000000000000000000008304909116917c0100000000000000000000000000000000000000000000000000000000900463ffffffff1690565b6000610df233848461259c565b5060015b92915050565b60065473ffffffffffffffffffffffffffffffffffffffff1681565b60005481565b73ffffffffffffffffffffffffffffffffffffffff831660009081526002602090815260408083203384529091528120547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff14610ee85773ffffffffffffffffffffffffffffffffffffffff84166000908152600260209081526040808320338452909152902054610eb6908363ffffffff61226e16565b73ffffffffffffffffffffffffffffffffffffffff851660009081526002602090815260408083203384529091529020555b610ef384848461260b565b5060019392505050565b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c981565b601281565b60035481565b60055473ffffffffffffffffffffffffffffffffffffffff163314610fb257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f556e697377617056323a20464f5242494444454e000000000000000000000000604482015290519081900360640190fd5b6006805473ffffffffffffffffffffffffffffffffffffffff9384167fffffffffffffffffffffffff00000000000000000000000000000000000000009182161790915560078054929093169116179055565b60095481565b600a5481565b6000600c5460011461108457604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c81905580611094610d90565b50600654604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905193955091935060009273ffffffffffffffffffffffffffffffffffffffff909116916370a08231916024808301926020929190829003018186803b15801561110e57600080fd5b505afa158015611122573d6000803e3d6000fd5b505050506040513d602081101561113857600080fd5b5051600754604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905192935060009273ffffffffffffffffffffffffffffffffffffffff909216916370a0823191602480820192602092909190829003018186803b1580156111b157600080fd5b505afa1580156111c5573d6000803e3d6000fd5b505050506040513d60208110156111db57600080fd5b505190506000611201836dffffffffffffffffffffffffffff871663ffffffff61226e16565b90506000611225836dffffffffffffffffffffffffffff871663ffffffff61226e16565b9050600061123387876126ec565b600054909150806112705761125c6103e8610bfd611257878763ffffffff6121e816565b612878565b985061126b60006103e86128ca565b6112cd565b6112ca6dffffffffffffffffffffffffffff8916611294868463ffffffff6121e816565b8161129b57fe5b046dffffffffffffffffffffffffffff89166112bd868563ffffffff6121e816565b816112c457fe5b0461297a565b98505b60008911611326576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526028815260200180612bc16028913960400191505060405180910390fd5b6113308a8a6128ca565b61133c86868a8a6122e0565b811561137e5760085461137a906dffffffffffffffffffffffffffff808216916e01000000000000000000000000000090041663ffffffff6121e816565b600b555b6040805185815260208101859052815133927f4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f928290030190a250506001600c5550949695505050505050565b60016020526000908152604090205481565b600b5481565b60046020526000908152604090205481565b600080600c5460011461146957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c81905580611479610d90565b50600654600754604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905194965092945073ffffffffffffffffffffffffffffffffffffffff9182169391169160009184916370a08231916024808301926020929190829003018186803b1580156114fb57600080fd5b505afa15801561150f573d6000803e3d6000fd5b505050506040513d602081101561152557600080fd5b5051604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905191925060009173ffffffffffffffffffffffffffffffffffffffff8516916370a08231916024808301926020929190829003018186803b15801561159957600080fd5b505afa1580156115ad573d6000803e3d6000fd5b505050506040513d60208110156115c357600080fd5b5051306000908152600160205260408120549192506115e288886126ec565b600054909150806115f9848763ffffffff6121e816565b8161160057fe5b049a5080611614848663ffffffff6121e816565b8161161b57fe5b04995060008b11801561162e575060008a115b611683576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526028815260200180612b996028913960400191505060405180910390fd5b61168d3084612992565b611698878d8d611fdb565b6116a3868d8c611fdb565b604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905173ffffffffffffffffffffffffffffffffffffffff8916916370a08231916024808301926020929190829003018186803b15801561170f57600080fd5b505afa158015611723573d6000803e3d6000fd5b505050506040513d602081101561173957600080fd5b5051604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905191965073ffffffffffffffffffffffffffffffffffffffff8816916370a0823191602480820192602092909190829003018186803b1580156117ab57600080fd5b505afa1580156117bf573d6000803e3d6000fd5b505050506040513d60208110156117d557600080fd5b505193506117e585858b8b6122e0565b811561182757600854611823906dffffffffffffffffffffffffffff808216916e01000000000000000000000000000090041663ffffffff6121e816565b600b555b604080518c8152602081018c9052815173ffffffffffffffffffffffffffffffffffffffff8f169233927fdccd412f0b1252819cb1fd330b93224ca42612892bb3f4f789976e6d81936496929081900390910190a35050505050505050506001600c81905550915091565b6040518060400160405280600681526020017f554e492d5632000000000000000000000000000000000000000000000000000081525081565b6000610df233848461260b565b6103e881565b600c5460011461194f57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c55600654600754600854604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905173ffffffffffffffffffffffffffffffffffffffff9485169490931692611a2b9285928792611a26926dffffffffffffffffffffffffffff169185916370a0823191602480820192602092909190829003018186803b1580156119ee57600080fd5b505afa158015611a02573d6000803e3d6000fd5b505050506040513d6020811015611a1857600080fd5b50519063ffffffff61226e16565b611fdb565b600854604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051611aca9284928792611a26926e01000000000000000000000000000090046dffffffffffffffffffffffffffff169173ffffffffffffffffffffffffffffffffffffffff8616916370a0823191602480820192602092909190829003018186803b1580156119ee57600080fd5b50506001600c5550565b60055473ffffffffffffffffffffffffffffffffffffffff1681565b60075473ffffffffffffffffffffffffffffffffffffffff1681565b42841015611b7b57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f556e697377617056323a20455850495245440000000000000000000000000000604482015290519081900360640190fd5b60035473ffffffffffffffffffffffffffffffffffffffff80891660008181526004602090815260408083208054600180820190925582517f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98186015280840196909652958d166060860152608085018c905260a085019590955260c08085018b90528151808603909101815260e0850182528051908301207f19010000000000000000000000000000000000000000000000000000000000006101008601526101028501969096526101228085019690965280518085039096018652610142840180825286519683019690962095839052610162840180825286905260ff89166101828501526101a284018890526101c28401879052519193926101e2808201937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe081019281900390910190855afa158015611cdc573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff811615801590611d5757508873ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b611dc257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f556e697377617056323a20494e56414c49445f5349474e415455524500000000604482015290519081900360640190fd5b611dcd89898961259c565b505050505050505050565b600260209081526000928352604080842090915290825290205481565b600c54600114611e6657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f556e697377617056323a204c4f434b4544000000000000000000000000000000604482015290519081900360640190fd5b6000600c55600654604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051611fd49273ffffffffffffffffffffffffffffffffffffffff16916370a08231916024808301926020929190829003018186803b158015611edd57600080fd5b505afa158015611ef1573d6000803e3d6000fd5b505050506040513d6020811015611f0757600080fd5b5051600754604080517f70a08231000000000000000000000000000000000000000000000000000000008152306004820152905173ffffffffffffffffffffffffffffffffffffffff909216916370a0823191602480820192602092909190829003018186803b158015611f7a57600080fd5b505afa158015611f8e573d6000803e3d6000fd5b505050506040513d6020811015611fa457600080fd5b50516008546dffffffffffffffffffffffffffff808216916e0100000000000000000000000000009004166122e0565b6001600c55565b604080518082018252601981527f7472616e7366657228616464726573732c75696e743235362900000000000000602091820152815173ffffffffffffffffffffffffffffffffffffffff85811660248301526044808301869052845180840390910181526064909201845291810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb000000000000000000000000000000000000000000000000000000001781529251815160009460609489169392918291908083835b602083106120e157805182527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe090920191602091820191016120a4565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114612143576040519150601f19603f3d011682016040523d82523d6000602084013e612148565b606091505b5091509150818015612176575080511580612176575080806020019051602081101561217357600080fd5b50515b6121e157604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f556e697377617056323a205452414e534645525f4641494c4544000000000000604482015290519081900360640190fd5b5050505050565b60008115806122035750508082028282828161220057fe5b04145b610df657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f64732d6d6174682d6d756c2d6f766572666c6f77000000000000000000000000604482015290519081900360640190fd5b80820382811115610df657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f64732d6d6174682d7375622d756e646572666c6f770000000000000000000000604482015290519081900360640190fd5b6dffffffffffffffffffffffffffff841180159061230c57506dffffffffffffffffffffffffffff8311155b61237757604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f556e697377617056323a204f564552464c4f5700000000000000000000000000604482015290519081900360640190fd5b60085463ffffffff428116917c0100000000000000000000000000000000000000000000000000000000900481168203908116158015906123c757506dffffffffffffffffffffffffffff841615155b80156123e257506dffffffffffffffffffffffffffff831615155b15612492578063ffffffff16612425856123fb86612a57565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff169063ffffffff612a7b16565b600980547bffffffffffffffffffffffffffffffffffffffffffffffffffffffff929092169290920201905563ffffffff8116612465846123fb87612a57565b600a80547bffffffffffffffffffffffffffffffffffffffffffffffffffffffff92909216929092020190555b600880547fffffffffffffffffffffffffffffffffffff0000000000000000000000000000166dffffffffffffffffffffffffffff888116919091177fffffffff0000000000000000000000000000ffffffffffffffffffffffffffff166e0100000000000000000000000000008883168102919091177bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167c010000000000000000000000000000000000000000000000000000000063ffffffff871602179283905560408051848416815291909304909116602082015281517f1c411e9a96e071241c2f21f7726b17ae89e3cab4c78be50e062b03a9fffbbad1929181900390910190a1505050505050565b73ffffffffffffffffffffffffffffffffffffffff808416600081815260026020908152604080832094871680845294825291829020859055815185815291517f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259281900390910190a3505050565b73ffffffffffffffffffffffffffffffffffffffff8316600090815260016020526040902054612641908263ffffffff61226e16565b73ffffffffffffffffffffffffffffffffffffffff8085166000908152600160205260408082209390935590841681522054612683908263ffffffff612abc16565b73ffffffffffffffffffffffffffffffffffffffff80841660008181526001602090815260409182902094909455805185815290519193928716927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef92918290030190a3505050565b600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663017e7e586040518163ffffffff1660e01b815260040160206040518083038186803b15801561275757600080fd5b505afa15801561276b573d6000803e3d6000fd5b505050506040513d602081101561278157600080fd5b5051600b5473ffffffffffffffffffffffffffffffffffffffff821615801594509192509061286457801561285f5760006127d86112576dffffffffffffffffffffffffffff88811690881663ffffffff6121e816565b905060006127e583612878565b90508082111561285c576000612813612804848463ffffffff61226e16565b6000549063ffffffff6121e816565b905060006128388361282c86600563ffffffff6121e816565b9063ffffffff612abc16565b9050600081838161284557fe5b04905080156128585761285887826128ca565b5050505b50505b612870565b8015612870576000600b555b505092915050565b600060038211156128bb575080600160028204015b818110156128b5578091506002818285816128a457fe5b0401816128ad57fe5b04905061288d565b506128c5565b81156128c5575060015b919050565b6000546128dd908263ffffffff612abc16565b600090815573ffffffffffffffffffffffffffffffffffffffff8316815260016020526040902054612915908263ffffffff612abc16565b73ffffffffffffffffffffffffffffffffffffffff831660008181526001602090815260408083209490945583518581529351929391927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9281900390910190a35050565b6000818310612989578161298b565b825b9392505050565b73ffffffffffffffffffffffffffffffffffffffff82166000908152600160205260409020546129c8908263ffffffff61226e16565b73ffffffffffffffffffffffffffffffffffffffff831660009081526001602052604081209190915554612a02908263ffffffff61226e16565b600090815560408051838152905173ffffffffffffffffffffffffffffffffffffffff8516917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef919081900360200190a35050565b6dffffffffffffffffffffffffffff166e0100000000000000000000000000000290565b60006dffffffffffffffffffffffffffff82167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff841681612ab457fe5b049392505050565b80820182811015610df657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f64732d6d6174682d6164642d6f766572666c6f77000000000000000000000000604482015290519081900360640190fdfe556e697377617056323a20494e53554646494349454e545f4f55545055545f414d4f554e54556e697377617056323a20494e53554646494349454e545f494e5055545f414d4f554e54556e697377617056323a20494e53554646494349454e545f4c4951554944495459556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e4544556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e544544a265627a7a723158207dca18479e58487606bf70c79e44d8dee62353c9ee6d01f9a9d70885b8765f2264736f6c63430005100032454950373132446f6d61696e28737472696e67206e616d652c737472696e672076657273696f6e2c75696e7432353620636861696e49642c6164647265737320766572696679696e67436f6e747261637429a265627a7a723158202760f92d7fa1db6f5aa16307bad65df4ebcc8550c4b1f03755ab8dfd830c178f64736f6c63430005100032000000000000000000000000{_sender}";

    impl PlanConfig<String> for MockConfig {
        fn get_env(&self) -> Result<HashMap<String, String>> {
            Ok(HashMap::<String, String>::from_iter([
                ("test1".to_owned(), "0xbeef".to_owned()),
                ("test2".to_owned(), "0x9001".to_owned()),
            ]))
        }

        fn get_create_steps(&self) -> Result<Vec<CreateDefinition>> {
            Ok(vec![
                CreateDefinition {
                    bytecode: COUNTER_BYTECODE.to_string(),
                    name: "test_counter".to_string(),
                    from: Some("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266".to_owned()),
                    from_pool: None,
                },
                CreateDefinition {
                    bytecode: COUNTER_BYTECODE.to_string(),
                    name: "test_counter2".to_string(),
                    from: None,
                    from_pool: Some("admin1".to_owned()),
                },
                CreateDefinition {
                    bytecode: COUNTER_BYTECODE.to_string(),
                    name: "test_counter3".to_string(),
                    from: None,
                    from_pool: Some("admin2".to_owned()),
                },
                CreateDefinition {
                    bytecode: UNI_V2_FACTORY_BYTECODE.to_string(),
                    name: "univ2_factory".to_string(),
                    from: None,
                    from_pool: Some("admin1".to_owned()),
                },
                CreateDefinition {
                    bytecode: UNI_V2_FACTORY_BYTECODE.to_string(),
                    name: "univ2_factory".to_string(),
                    from: Some("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266".to_owned()),
                    from_pool: None,
                },
            ])
        }

        fn get_setup_steps(&self) -> Result<Vec<FunctionCallDefinition>> {
            Ok(vec![
                FunctionCallDefinition {
                    to: "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D".to_owned(),
                    from: Some("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266".to_owned()),
                    from_pool: None,
                    value: Some("4096".to_owned()),
                    signature: "swap(uint256 x, uint256 y, address a, bytes b)".to_owned(),
                    args: vec![
                        "1".to_owned(),
                        "2".to_owned(),
                        Address::repeat_byte(0x11).encode_hex(),
                        "0xdead".to_owned(),
                    ]
                    .into(),
                    fuzz: None,
                    kind: None,
                    gas_limit: None,
                },
                FunctionCallDefinition {
                    to: "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D".to_owned(),
                    from: Some("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266".to_owned()),
                    from_pool: None,
                    value: Some("0x1000".to_owned()),
                    signature: "swap(uint256 x, uint256 y, address a, bytes b)".to_owned(),
                    args: vec![
                        "1".to_owned(),
                        "2".to_owned(),
                        Address::repeat_byte(0x11).encode_hex(),
                        "0xbeef".to_owned(),
                    ]
                    .into(),
                    fuzz: None,
                    kind: None,
                    gas_limit: None,
                },
                FunctionCallDefinition {
                    to: "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D".to_owned(),
                    from: None,
                    from_pool: Some("pool1".to_owned()),
                    value: None,
                    signature: "increment()".to_owned(),
                    args: vec![].into(),
                    fuzz: None,
                    kind: None,
                    gas_limit: None,
                },
            ])
        }

        fn get_spam_steps(&self) -> Result<Vec<SpamRequest>> {
            Ok(vec![
                SpamRequest::Tx(FunctionCallDefinition {
                    to: "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D".to_owned(),
                    from: None,
                    from_pool: Some("pool1".to_owned()),
                    value: None,
                    signature: "swap(uint256 x, uint256 y, address a, bytes b)".to_owned(),
                    args: vec![
                        "1".to_owned(),
                        "2".to_owned(),
                        // {_sender} will be replaced with the `from` address
                        "{_sender}".to_owned(),
                        "0xd00d".to_owned(),
                    ]
                    .into(),
                    fuzz: vec![FuzzParam {
                        param: Some("x".to_string()),
                        value: None,
                        min: None,
                        max: None,
                    }]
                    .into(),
                    kind: None,
                    gas_limit: None,
                }),
                SpamRequest::Tx(FunctionCallDefinition {
                    to: "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D".to_owned(),
                    from: None,
                    from_pool: Some("pool2".to_owned()),
                    value: None,
                    signature: "swap(uint256 x, uint256 y, address a, bytes b)".to_owned(),
                    args: vec![
                        "1".to_owned(),
                        "2".to_owned(),
                        // {_sender} will be replaced with the `from` address
                        "{_sender}".to_owned(),
                        "0xd00d".to_owned(),
                    ]
                    .into(),
                    fuzz: vec![FuzzParam {
                        param: Some("x".to_string()),
                        value: None,
                        min: None,
                        max: None,
                    }]
                    .into(),
                    kind: None,
                    gas_limit: None,
                }),
                SpamRequest::Tx(FunctionCallDefinition {
                    to: "0x00000000000000000000000000000000f007ba11".to_owned(),
                    from: None,
                    from_pool: Some("pool2".to_owned()),
                    value: None,
                    signature: "swap(uint256 x, uint256 y, address a, bytes b)".to_owned(),
                    args: vec![
                        "1".to_owned(),
                        "2".to_owned(),
                        // {_sender} will be replaced with the `from` address
                        "{_sender}".to_owned(),
                        "0xd00d".to_owned(),
                    ]
                    .into(),
                    fuzz: vec![FuzzParam {
                        param: Some("x".to_string()),
                        value: None,
                        min: None,
                        max: None,
                    }]
                    .into(),
                    kind: None,
                    gas_limit: Some(100_000),
                }),
            ])
        }
    }

    impl Templater<String> for MockConfig {
        fn copy_end(&self, input: &str, _last_end: usize) -> String {
            input.to_owned()
        }
        fn replace_placeholders(
            &self,
            input: &str,
            _placeholder_map: &std::collections::HashMap<String, String>,
        ) -> String {
            input.to_owned()
        }
        fn terminator_start(&self, _input: &str) -> Option<usize> {
            None
        }
        fn terminator_end(&self, _input: &str) -> Option<usize> {
            None
        }
        fn num_placeholders(&self, _input: &str) -> usize {
            0
        }
        fn find_key(&self, _input: &str) -> Option<(String, usize)> {
            None
        }
    }

    pub async fn get_test_scenario(
        anvil: &AnvilInstance,
        txs_per_duration: u64,
        fund_amount_eth: f64,
    ) -> TestScenario<MockDb, RandSeed, MockConfig> {
        let seed = RandSeed::seed_from_bytes(&[0x01; 32]);
        let tx_type = alloy::consensus::TxType::Eip1559;
        let signers = get_test_signers();

        let mut agents = AgentStore::new();
        let config = MockConfig;
        let num_pools = config.get_spam_pools().len().max(1) as u64;
        println!("spam pools: {num_pools}, txs_per_duration: {txs_per_duration}");
        agents.init(
            &["pool1", "pool2"],
            (txs_per_duration / num_pools) as usize,
            &seed,
        );

        let admin1_signers = SignerStore::new(1, &seed, "admin1");
        let admin2_signers = SignerStore::new(1, &seed, "admin2");
        agents.add_agent("admin1", admin1_signers);
        agents.add_agent("admin2", admin2_signers);

        let mut scenario = TestScenario::new(
            config,
            MockDb.into(),
            seed.to_owned(),
            TestScenarioParams {
                rpc_url: anvil.endpoint_url(),
                builder_rpc_url: None,
                signers,
                agent_store: agents,
                tx_type,
                gas_price_percent_add: None,
                pending_tx_timeout_secs: 12,
            },
            None,
            (&PROM, &HIST),
        )
        .await
        .unwrap();

        let fund_amount_wei = U256::from(fund_amount_eth * 1e18);
        println!("fund_amount_wei: {fund_amount_wei}");
        println!("fund_amount_eth: {fund_amount_eth}");

        let all_agent_names = scenario
            .agent_store
            .all_agents()
            .map(|(name, _)| name.to_owned())
            .collect::<Vec<_>>();
        for agent_name in &all_agent_names {
            println!(
                "funding agent: {agent_name} (num signers: {})",
                scenario
                    .agent_store
                    .get_agent(agent_name)
                    .unwrap()
                    .signers
                    .len()
            );
            scenario
                .fund_agent_signers(agent_name, &anvil.wallet().unwrap(), fund_amount_wei)
                .await
                .unwrap();
        }

        scenario
    }

    #[tokio::test]
    async fn it_creates_scenarios() -> std::result::Result<(), Box<dyn std::error::Error>> {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, 10.0).await;

        let create_txs = scenario
            .load_txs(PlanType::Create(|tx| {
                println!("create tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await?;
        assert_eq!(create_txs.len(), 5);

        let setup_txs = scenario
            .load_txs(PlanType::Setup(|tx| {
                println!("setup tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await?;
        assert_eq!(setup_txs.len(), 3);

        let spam_txs = scenario
            .load_txs(PlanType::Spam(20, |tx| {
                println!("spam tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await?;

        // should round up to nearest multiple of 3 (3 spam steps in config, 20 txs requested)
        assert_eq!(spam_txs.len(), 21);
        Ok(())
    }

    #[tokio::test]
    async fn gas_limit_override_works() {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, 10.0).await;
        let spam_txs = scenario
            .load_txs(PlanType::Spam(20, |tx| {
                println!("spam tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await
            .unwrap();
        let tx = spam_txs
            .iter()
            .find(|tx| match tx {
                ExecutionRequest::Tx(tx) => {
                    *tx.tx.to.unwrap().to().unwrap()
                        == "0x00000000000000000000000000000000f007ba11"
                            .parse::<Address>()
                            .unwrap()
                }
                _ => false,
            })
            .unwrap();
        match tx {
            ExecutionRequest::Tx(tx) => {
                assert_eq!(tx.tx.gas, Some(100_000));
            }
            _ => panic!("expected tx"),
        }
    }

    #[tokio::test]
    async fn fncall_replaces_sender_placeholder_with_from_address() {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, 10.0).await;

        let spam_txs = scenario
            .load_txs(PlanType::Spam(10, |tx| {
                println!("spam tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await
            .unwrap();
        let spam_tx = &spam_txs[0];
        let tx = match spam_tx {
            ExecutionRequest::Tx(tx) => tx,
            _ => panic!("expected tx"),
        };
        let from = tx.tx.from.unwrap();
        let input = tx.tx.input.input.as_ref().unwrap();
        println!("input: {input}");
        println!("from: {}", from.encode_hex());
        assert!(input.encode_hex().contains(&from.encode_hex()));
    }

    #[tokio::test]
    async fn create_replaces_sender_placeholder_with_from_address() {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, 10.0).await;

        let txs = scenario
            .load_txs(PlanType::Create(|tx| {
                println!("create tx callback triggered! {tx:?}\n");
                Ok(None)
            }))
            .await
            .unwrap();
        for tx in &txs[3..4] {
            let tx = match tx {
                ExecutionRequest::Tx(tx) => tx,
                _ => panic!("expected tx"),
            };
            let from = tx.tx.from.unwrap();
            let input = tx.tx.input.input.as_ref().unwrap();
            println!("input: {input}");
            println!("from: {}", from.encode_hex());
            assert!(input.encode_hex().contains(&from.encode_hex()));
        }
    }

    #[tokio::test]
    async fn create_steps_use_agent_signers() {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, 10.0).await;

        // assert that the agent store has the correct number of signers
        let create_steps = scenario
            .load_txs(PlanType::Create(|_| Ok(None)))
            .await
            .unwrap();
        let mut used_agent_keys = 0;
        for step in create_steps {
            let tx = match step {
                ExecutionRequest::Tx(tx) => tx,
                _ => continue,
            };
            if tx.tx.from.is_some() {
                assert!(scenario.wallet_map.contains_key(&tx.tx.from.unwrap()));
            }
            assert!(scenario.agent_store.has_agent("admin1"));
            assert!(scenario.agent_store.has_agent("admin2"));
            let admin_pools = ["admin1", "admin2"];
            for pool in admin_pools {
                if scenario
                    .agent_store
                    .get_agent(pool)
                    .unwrap()
                    .signers
                    .iter()
                    .map(|s| s.address())
                    .collect::<Vec<_>>()
                    .contains(&tx.tx.from.unwrap())
                {
                    used_agent_keys += 1;
                }
            }
        }
        assert_eq!(used_agent_keys, 3);
    }

    #[tokio::test]
    async fn setup_steps_use_agent_signers() {
        let anvil = spawn_anvil();
        let mut scenario = get_test_scenario(&anvil, 10, 10.0).await;
        scenario.deploy_contracts().await.unwrap();
        let setup_steps = scenario
            .load_txs(PlanType::Setup(|_| Ok(None)))
            .await
            .unwrap();
        scenario.run_setup().await.unwrap();
        let mut used_agent_keys = 0;
        for step in setup_steps {
            let tx = match step {
                ExecutionRequest::Tx(tx) => tx,
                _ => continue,
            };
            let from = tx.tx.from.unwrap();
            assert!(scenario.wallet_map.contains_key(&from));
            assert!(scenario.agent_store.has_agent("pool1"));
            if scenario
                .agent_store
                .get_agent("pool1")
                .unwrap()
                .signers
                .iter()
                .map(|s| s.address())
                .collect::<Vec<_>>()
                .contains(&from)
            {
                used_agent_keys += 1;
            }
        }
        assert_eq!(used_agent_keys, 1);
    }

    #[tokio::test]
    async fn scenario_creates_contracts() {
        let anvil = spawn_anvil();
        let mut scenario = get_test_scenario(&anvil, 10, 10.0).await;
        let res = scenario.deploy_contracts().await;
        assert!(res.is_ok());
    }

    #[tokio::test]
    async fn scenario_runs_setup() {
        let anvil = spawn_anvil();
        let mut scenario = get_test_scenario(&anvil, 10, 10.0).await;
        scenario.deploy_contracts().await.unwrap();
        let res = scenario.run_setup().await;
        println!("{res:?}");
        assert!(res.is_ok());
    }

    #[tokio::test]
    async fn setup_cost_estimates_are_correct(
    ) -> std::result::Result<(), Box<dyn std::error::Error>> {
        let anvil = spawn_anvil();
        let scenario = get_test_scenario(&anvil, 10, 10.0).await;
        let cost = scenario.estimate_setup_cost().await?;
        let total_txs = scenario.config.get_setup_steps().unwrap().len()
            + scenario.config.get_create_steps().unwrap().len();
        let expected_cost_min = U256::from(GWEI_TO_WEI * 21000 * total_txs as u64); // assuming gas price is 1 gwei and txs are cheap
        assert!(cost > expected_cost_min);
        Ok(())
    }

    #[tokio::test]
    async fn all_tx_requests_are_contiguous() -> std::result::Result<(), Box<dyn std::error::Error>>
    {
        let anvil = spawn_anvil();
        let txs_per_duration = 500u64;
        let duration = 3;
        let mut scenario = get_test_scenario(&anvil, txs_per_duration, 0.01).await;

        // make tx chunks
        let tx_req_chunks = scenario
            .get_spam_tx_chunks(txs_per_duration, duration)
            .await?;

        // test chunk size & count
        assert_eq!(tx_req_chunks.len(), duration as usize);
        for chunk in tx_req_chunks.iter() {
            assert_eq!(chunk.len(), txs_per_duration as usize);
        }

        // prepare tx requests & collect them all into a single array
        let mut prepared_txs: Vec<crate::spammer::ExecutionPayload> = vec![];
        for chunk in tx_req_chunks {
            let tx_reqs = scenario.prepare_spam(&chunk).await?;
            prepared_txs.extend(tx_reqs);
        }

        // group prepared_txs by `from` address, then sort each group by nonce, then assert that all nonces are contiguous (no gaps)
        let mut grouped_txs = std::collections::HashMap::new();
        for tx in &prepared_txs {
            match tx {
                crate::spammer::ExecutionPayload::SignedTx(_, tx_req) => {
                    let from = tx_req.tx.from.unwrap();
                    let nonce = tx_req.tx.nonce.unwrap();
                    grouped_txs.entry(from).or_insert_with(Vec::new).push(nonce);
                }
                crate::spammer::ExecutionPayload::SignedTxBundle(_, _) => {
                    // ignore
                }
            }
        }
        for (from, nonces) in grouped_txs {
            let mut nonces = nonces;
            nonces.sort();
            let mut prev_nonce = nonces[0];
            let mut min_nonce = prev_nonce;
            let mut max_nonce = prev_nonce;
            for nonce in &nonces[1..] {
                assert_eq!(prev_nonce + 1, *nonce);
                prev_nonce = *nonce;
                if *nonce < min_nonce {
                    min_nonce = *nonce;
                }
                if *nonce > max_nonce {
                    max_nonce = *nonce;
                }
            }
            println!("({from}) min_nonce: {min_nonce}, max_nonce: {max_nonce}");
        }

        Ok(())
    }
}
