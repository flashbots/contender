use crate::commands::error::ArgsError;
use crate::commands::Result;
use crate::util::error::UtilError;
use alloy::hex::{self, ToHexExt};
use alloy::network::{EthereumWallet, TransactionBuilder};
use alloy::primitives::{Address, U256};
use alloy::providers::{Provider, ProviderBuilder};
use alloy::rpc::types::BlockId;
use clap::Subcommand;
use contender_core::{
    agent_controller::SignerStore,
    db::DbOps,
    generator::{util::generate_setcode_signer, RandSeed},
};
use contender_sqlite::SqliteDb;
use contender_testfile::TestConfig;
use std::path::Path;
use thiserror::Error;
use tracing::{info, warn};
use url::Url;

#[derive(Debug, Error)]
pub enum AdminError {
    #[error("seed file is empty. path: {0}")]
    SeedFileEmpty(String),

    #[error("failed to read seed file at path: {0}")]
    SeedFileDoesNotExist(String),

    #[error("invalid data in seed file at path: {0}")]
    SeedFileInvalid(String),

    #[error("failed to read input from stdin")]
    Readline(std::io::Error),

    #[error("genesis block not found for rpc url: {0}")]
    GenesisBlockMissing(String),

    #[error("contract '{0}' not found for the provided rpc url")]
    ContractNotFound(String),

    #[error("contract '{0}' has no stored address")]
    ContractAddressMissing(String),
}

#[derive(Debug, Subcommand)]
pub enum AdminCommand {
    #[command(
        name = "accounts",
        about = "Print addresses generated by RandSeed for a given from_pool"
    )]
    Accounts {
        /// From pool to generate accounts for
        #[arg(short = 'f', long)]
        from_pool: String,

        /// Number of signers to generate
        #[arg(short = 'n', long, default_value = "10")]
        num_signers: usize,
    },

    #[command(name = "latest-run-id", about = "Print the max run id in the DB")]
    LatestRunId,

    #[command(name = "seed", about = "Print the contents of ~/.contender/seed")]
    Seed,

    #[command(
        name = "setcode-signer",
        about = "Print the private key & address of the signer used for setCode Authorization signatures."
    )]
    SetCodeSigner,

    #[command(
        name = "reclaim-eth",
        about = "Reclaim ETH from spammer accounts back to a recipient address"
    )]
    ReclaimEth {
        /// Recipient address
        #[arg(
            long,
            short = 't',
            default_value = "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
        )]
        to: Address,

        /// RPC URL (defaults to http://localhost:8545 or derived from scenario)
        #[arg(long, short = 'r')]
        rpc: Option<String>,

        /// Agent names to derive accounts from (can be specified multiple times)
        #[arg(long, short = 'f', action = clap::ArgAction::Append)]
        from_pool: Vec<String>,

        /// Number of accounts to derive per agent
        #[arg(long, short = 'n', default_value_t = 10)]
        num_signers: usize,

        /// Scenario file to derive agents and RPC URL from
        scenario_file: Option<String>,
    },

    #[command(
        name = "contract-address",
        about = "Lookup a deployed contract address by name and RPC URL"
    )]
    ContractAddress {
        /// RPC URL (defaults to http://localhost:8545)
        #[arg(
            env = "RPC_URL",
            long,
            short = 'r',
            default_value = "http://localhost:8545"
        )]
        rpc_url: Url,

        /// Contract name to look up
        contract_name: String,
    },
}

/// Reads and validates the seed file
fn read_seed_file(data_dir: &str) -> Result<Vec<u8>> {
    let seed_path = format!("{data_dir}/seed");
    let seed_hex = std::fs::read_to_string(&seed_path)
        .map_err(|_| AdminError::SeedFileDoesNotExist(seed_path.to_owned()))?;
    let decoded = hex::decode(seed_hex.trim())
        .map_err(|_| AdminError::SeedFileInvalid(seed_path.to_owned()))?;
    if decoded.is_empty() {
        return Err(AdminError::SeedFileEmpty(seed_path).into());
    }
    Ok(decoded)
}

/// Prompts for confirmation before displaying sensitive information
fn confirm_sensitive_operation(_operation: &str) -> Result<()> {
    println!("WARNING: This command will display sensitive information.");
    println!("This information should not be shared or exposed in CI environments.");
    println!("Press Enter to continue or Ctrl+C to cancel...");
    let mut input = String::new();
    std::io::stdin()
        .read_line(&mut input)
        .map_err(AdminError::Readline)?;
    Ok(())
}

/// Handles the accounts subcommand
fn handle_accounts(from_pool: String, num_signers: usize, data_dir: &str) -> Result<()> {
    let seed_bytes = read_seed_file(data_dir)?;
    let seed = RandSeed::seed_from_bytes(&seed_bytes);
    print_accounts_for_pool(&from_pool, num_signers, &seed)?;
    Ok(())
}

/// Prints accounts for a specific pool
fn print_accounts_for_pool(pool: &str, num_signers: usize, seed: &RandSeed) -> Result<()> {
    info!("Generating addresses for pool: {}", pool);
    let agent = SignerStore::new(num_signers, seed, pool);
    let mut private_keys = vec![];
    for (i, address) in agent.all_addresses().iter().enumerate() {
        private_keys.push(format!(
            "0x{}",
            hex::encode(agent.signers[i].credential().to_bytes())
        ));
        println!("Signer {i}: {address}");
    }
    println!("---------------------------------");
    for (i, key) in private_keys.iter().enumerate() {
        println!("Private Key {i}: {key}");
    }
    Ok(())
}

/// Handles the seed subcommand
fn handle_seed(data_dir: &str) -> Result<()> {
    confirm_sensitive_operation("displaying seed value")?;
    let seed_bytes = read_seed_file(data_dir)?;
    println!("{}", hex::encode(seed_bytes));
    Ok(())
}

fn print_setcode_account(data_dir: &str) -> Result<()> {
    confirm_sensitive_operation("displaying private key")?;
    let seed_bytes = read_seed_file(data_dir)?;
    let seed = RandSeed::seed_from_bytes(&seed_bytes);
    let (signer, key) = generate_setcode_signer(&seed);
    println!("Address:\t{}", signer.address());
    println!("Private Key:\t0x{}", key.encode_hex());
    Ok(())
}

/// Handles the reclaim-eth subcommand
async fn handle_reclaim_eth(
    recipient: Address,
    rpc: Option<String>,
    from_pool: Vec<String>,
    num_accounts: usize,
    scenario_file: Option<String>,
    data_dir: &str,
    db: &SqliteDb,
) -> Result<()> {
    // Determine RPC URL and from_pools
    let (rpc_url, agent_pools) = if let Some(scenario_path) = scenario_file {
        let config = TestConfig::from_file(&scenario_path)?;

        // Extract from_pools from scenario
        let mut pools = std::collections::HashSet::new();

        // insert default pools (scenarios may not have any from_pools, which means they'll use the defaults)
        pools.insert("admin".to_owned());
        pools.insert("spammers".to_owned());

        // Get from_pools from create definitions
        if let Some(create_defs) = &config.create {
            for def in create_defs {
                if let Some(pool) = &def.from_pool {
                    pools.insert(pool.clone());
                }
            }
        }

        // Get from_pools from setup definitions
        if let Some(setup_defs) = &config.setup {
            for def in setup_defs {
                if let Some(pool) = &def.from_pool {
                    pools.insert(pool.clone());
                }
            }
        }

        // Get from_pools from spam definitions
        if let Some(spam_defs) = &config.spam {
            for spam_req in spam_defs {
                match spam_req {
                    contender_core::generator::types::SpamRequest::Tx(tx_def) => {
                        if let Some(pool) = &tx_def.from_pool {
                            pools.insert(pool.clone());
                        }
                    }
                    contender_core::generator::types::SpamRequest::Bundle(bundle_def) => {
                        for tx_def in &bundle_def.txs {
                            if let Some(pool) = &tx_def.from_pool {
                                pools.insert(pool.clone());
                            }
                        }
                    }
                }
            }
        }

        // Use provided from_pool args or all from scenario
        let final_pools = if from_pool.is_empty() {
            pools.into_iter().collect()
        } else {
            from_pool
        };

        // Get RPC URL from scenario name or use provided
        let scenario_name = Path::new(&scenario_path)
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("unknown");

        let rpc_url = if let Some(rpc) = rpc {
            rpc
        } else {
            db.get_rpc_url_for_scenario(scenario_name)?
                .unwrap_or_else(|| "http://localhost:8545".to_string())
        };

        (rpc_url, final_pools)
    } else {
        // No scenario file provided
        let rpc_url = rpc.unwrap_or_else(|| "http://localhost:8545".to_string());
        let agent_pools = if from_pool.is_empty() {
            vec!["spammers".to_string()] // Default pool
        } else {
            from_pool
        };

        (rpc_url, agent_pools)
    };

    info!(
        "Reclaiming ETH from {} pools with {} accounts each",
        agent_pools.len(),
        num_accounts
    );
    info!("RPC URL: {}", rpc_url);
    info!("Recipient: {}", recipient);

    // Create provider
    let provider =
        ProviderBuilder::new().connect_http(rpc_url.parse().map_err(ArgsError::UrlParse)?);

    // Generate accounts from seed
    let seed_bytes = read_seed_file(data_dir)?;
    let seed = RandSeed::seed_from_bytes(&seed_bytes);

    let mut total_reclaimed = U256::ZERO;
    let mut total_accounts = 0;

    for pool_name in agent_pools {
        info!("Processing pool: {}", pool_name);

        // Generate signers for this pool
        let signer_store = SignerStore::new(num_accounts, &seed, &pool_name);

        for (i, signer) in signer_store.signers.iter().enumerate() {
            let address = signer.address();

            // Get balance
            let balance = provider.get_balance(address).await?;

            if balance == U256::ZERO {
                continue; // Skip empty accounts
            }

            info!(
                "Account {}/{}: {} has balance {} ETH",
                i + 1,
                num_accounts,
                address,
                alloy::primitives::utils::format_ether(balance)
            );

            // Calculate gas cost for transfer (21000 gas)
            let gas_price = provider.get_gas_price().await?;
            let gas_cost = U256::from(gas_price) * U256::from(21000);

            if balance <= gas_cost {
                warn!(
                    "Skipping {}: balance {} <= gas cost {}",
                    address, balance, gas_cost
                );
                continue;
            }

            // Amount to transfer (balance - gas cost)
            let transfer_amount = balance - gas_cost;

            // Create and send transaction
            let nonce = provider.get_transaction_count(address).await?;
            let chain_id = provider.get_chain_id().await?;

            let tx_req = alloy::rpc::types::TransactionRequest::default()
                .from(address)
                .to(recipient)
                .value(transfer_amount)
                .nonce(nonce)
                .gas_limit(21000)
                .gas_price(gas_price)
                .with_chain_id(chain_id);

            let wallet = EthereumWallet::from(signer.clone());
            let signed_tx = tx_req
                .build(&wallet)
                .await
                .map_err(UtilError::BuildTxFailed)?;

            let pending = provider.send_tx_envelope(signed_tx).await?;
            let tx_hash = pending.tx_hash();

            info!(
                "Sent {} ETH from {} to {} (tx: {})",
                alloy::primitives::utils::format_ether(transfer_amount),
                address,
                recipient,
                tx_hash
            );

            total_reclaimed += transfer_amount;
            total_accounts += 1;

            // Small delay to avoid overwhelming the RPC
            tokio::time::sleep(std::time::Duration::from_millis(100)).await;
        }
    }

    info!(
        "Reclaimed {} ETH from {} accounts",
        alloy::primitives::utils::format_ether(total_reclaimed),
        total_accounts
    );

    Ok(())
}

async fn handle_contract_address(contract_name: String, rpc_url: Url, db: &SqliteDb) -> Result<()> {
    let provider = ProviderBuilder::new().connect_http(rpc_url.clone());
    let genesis_block = provider.get_block(BlockId::earliest()).await?;
    if genesis_block.is_none() {
        return Err(AdminError::GenesisBlockMissing(rpc_url.to_string()).into());
    }
    let genesis_hash = genesis_block.expect("genesis block").header.hash;

    let named_tx = db
        .get_named_tx(&contract_name, rpc_url.as_str(), genesis_hash)?
        .ok_or_else(|| AdminError::ContractNotFound(contract_name.clone()))?;

    let address = named_tx
        .address
        .ok_or(AdminError::ContractAddressMissing(contract_name))?;
    println!("{address}");
    Ok(())
}

pub async fn handle_admin_command(
    command: AdminCommand,
    data_dir: &str,
    db: SqliteDb,
) -> Result<()> {
    match command {
        AdminCommand::Accounts {
            from_pool,
            num_signers,
        } => handle_accounts(from_pool, num_signers, data_dir),
        AdminCommand::LatestRunId => {
            let num_runs = db.num_runs()?;
            info!("Latest run ID: {num_runs}");
            println!("{num_runs}");
            Ok(())
        }
        AdminCommand::Seed => handle_seed(data_dir),
        AdminCommand::SetCodeSigner => print_setcode_account(data_dir),
        AdminCommand::ReclaimEth {
            to,
            rpc,
            from_pool,
            num_signers,
            scenario_file,
        } => {
            handle_reclaim_eth(
                to,
                rpc,
                from_pool,
                num_signers,
                scenario_file,
                data_dir,
                &db,
            )
            .await
        }
        AdminCommand::ContractAddress {
            contract_name,
            rpc_url,
        } => handle_contract_address(contract_name, rpc_url, &db).await,
    }
}
