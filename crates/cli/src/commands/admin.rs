use crate::util::data_dir;
use alloy::hex;
use clap::Subcommand;
use contender_core::{
    agent_controller::SignerStore, db::DbOps, error::ContenderError, generator::RandSeed,
};
use tracing::{info, warn};

#[derive(Debug, Subcommand)]
pub enum AdminCommand {
    #[command(
        name = "accounts",
        about = "Print addresses generated by RandSeed for a given from_pool"
    )]
    Accounts {
        /// From pool to generate accounts for
        #[arg(short = 'f', long)]
        from_pool: String,

        /// Number of signers to generate
        #[arg(short = 'n', long, default_value = "10")]
        num_signers: usize,
    },

    #[command(name = "latest-run-id", about = "Print the max run id in the DB")]
    LatestRunId,

    #[command(name = "seed", about = "Print the contents of ~/.contender/seed")]
    Seed,
}

/// Reads and validates the seed file
fn read_seed_file() -> Result<Vec<u8>, ContenderError> {
    let data_dir = data_dir()
        .map_err(|e| ContenderError::GenericError("Failed to get data dir", e.to_string()))?;
    let seed_path = format!("{data_dir}/seed");
    let seed_hex = std::fs::read_to_string(&seed_path).map_err(|e| {
        ContenderError::AdminError("Failed to read seed file", format!("at {seed_path}: {e}"))
    })?;
    let decoded = hex::decode(seed_hex.trim()).map_err(|_| {
        ContenderError::AdminError("Invalid hex data in seed file", format!("at {seed_path}"))
    })?;
    if decoded.is_empty() {
        return Err(ContenderError::AdminError(
            "Empty seed file",
            format!("at {seed_path}"),
        ));
    }
    Ok(decoded)
}

/// Prompts for confirmation before displaying sensitive information
fn confirm_sensitive_operation(_operation: &str) -> Result<(), ContenderError> {
    warn!("WARNING: This command will display sensitive information.");
    warn!("This information should not be shared or exposed in CI environments.");
    info!("Press Enter to continue or Ctrl+C to cancel...");
    let mut input = String::new();
    std::io::stdin()
        .read_line(&mut input)
        .map_err(|e| ContenderError::AdminError("Failed to read input", format!("{e}")))?;
    Ok(())
}

/// Handles the accounts subcommand
fn handle_accounts(
    from_pool: String,
    num_signers: usize,
) -> Result<(), Box<dyn std::error::Error>> {
    let seed_bytes = read_seed_file()?;
    let seed = RandSeed::seed_from_bytes(&seed_bytes);
    print_accounts_for_pool(&from_pool, num_signers, &seed)?;
    Ok(())
}

/// Prints accounts for a specific pool
fn print_accounts_for_pool(
    pool: &str,
    num_signers: usize,
    seed: &RandSeed,
) -> Result<(), ContenderError> {
    info!("Generating addresses for pool: {}", pool);
    let agent = SignerStore::new(num_signers, seed, pool);
    for (i, address) in agent.all_addresses().iter().enumerate() {
        info!("Signer {}: {}", i, address);
    }
    Ok(())
}

/// Handles the seed subcommand
fn handle_seed() -> Result<(), Box<dyn std::error::Error>> {
    confirm_sensitive_operation("displaying seed value")?;
    let seed_bytes = read_seed_file()?;
    info!("{}", hex::encode(seed_bytes));
    Ok(())
}

pub fn handle_admin_command(
    command: AdminCommand,
    db: impl DbOps,
) -> Result<(), Box<dyn std::error::Error>> {
    match command {
        AdminCommand::Accounts {
            from_pool,
            num_signers,
        } => handle_accounts(from_pool, num_signers),
        AdminCommand::LatestRunId => {
            let num_runs = db.num_runs()?;
            info!("Latest run ID: {num_runs}");
            Ok(())
        }
        AdminCommand::Seed => handle_seed(),
    }
}
