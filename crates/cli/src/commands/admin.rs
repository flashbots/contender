use crate::util::data_dir;
use alloy::hex::{self, ToHexExt};
use clap::Subcommand;
use contender_core::{
    agent_controller::SignerStore,
    db::DbOps,
    error::ContenderError,
    generator::{util::generate_setcode_signer, RandSeed},
};
use tracing::info;

#[derive(Debug, Subcommand)]
pub enum AdminCommand {
    #[command(
        name = "accounts",
        about = "Print addresses generated by RandSeed for a given from_pool"
    )]
    Accounts {
        /// From pool to generate accounts for
        #[arg(short = 'f', long)]
        from_pool: String,

        /// Number of signers to generate
        #[arg(short = 'n', long, default_value = "10")]
        num_signers: usize,
    },

    #[command(name = "latest-run-id", about = "Print the max run id in the DB")]
    LatestRunId,

    #[command(name = "seed", about = "Print the contents of ~/.contender/seed")]
    Seed,

    #[command(
        name = "setcode-signer",
        about = "Print the private key & address of the signer used for setCode Authorization signatures."
    )]
    SetCodeSigner,
}

/// Reads and validates the seed file
fn read_seed_file() -> Result<Vec<u8>, ContenderError> {
    let data_dir = data_dir()
        .map_err(|e| ContenderError::GenericError("Failed to get data dir", e.to_string()))?;
    let seed_path = format!("{data_dir}/seed");
    let seed_hex = std::fs::read_to_string(&seed_path).map_err(|e| {
        ContenderError::AdminError("Failed to read seed file", format!("at {seed_path}: {e}"))
    })?;
    let decoded = hex::decode(seed_hex.trim()).map_err(|_| {
        ContenderError::AdminError("Invalid hex data in seed file", format!("at {seed_path}"))
    })?;
    if decoded.is_empty() {
        return Err(ContenderError::AdminError(
            "Empty seed file",
            format!("at {seed_path}"),
        ));
    }
    Ok(decoded)
}

/// Prompts for confirmation before displaying sensitive information
fn confirm_sensitive_operation(_operation: &str) -> Result<(), ContenderError> {
    println!("WARNING: This command will display sensitive information.");
    println!("This information should not be shared or exposed in CI environments.");
    println!("Press Enter to continue or Ctrl+C to cancel...");
    let mut input = String::new();
    std::io::stdin()
        .read_line(&mut input)
        .map_err(|e| ContenderError::AdminError("Failed to read input", format!("{e}")))?;
    Ok(())
}

/// Handles the accounts subcommand
fn handle_accounts(
    from_pool: String,
    num_signers: usize,
) -> Result<(), Box<dyn std::error::Error>> {
    let seed_bytes = read_seed_file()?;
    let seed = RandSeed::seed_from_bytes(&seed_bytes);
    print_accounts_for_pool(&from_pool, num_signers, &seed)?;
    Ok(())
}

/// Prints accounts for a specific pool
fn print_accounts_for_pool(
    pool: &str,
    num_signers: usize,
    seed: &RandSeed,
) -> Result<(), ContenderError> {
    info!("Generating addresses for pool: {}", pool);
    let agent = SignerStore::new(num_signers, seed, pool);
    let mut private_keys = vec![];
    for (i, address) in agent.all_addresses().iter().enumerate() {
        private_keys.push(format!(
            "0x{}",
            hex::encode(agent.signers[i].credential().to_bytes())
        ));
        println!("Signer {i}: {address}");
    }
    println!("---------------------------------");
    for (i, key) in private_keys.iter().enumerate() {
        println!("Private Key {i}: {key}");
    }
    Ok(())
}

/// Handles the seed subcommand
fn handle_seed() -> Result<(), Box<dyn std::error::Error>> {
    confirm_sensitive_operation("displaying seed value")?;
    let seed_bytes = read_seed_file()?;
    println!("{}", hex::encode(seed_bytes));
    Ok(())
}

fn print_setcode_account() -> Result<(), Box<dyn std::error::Error>> {
    confirm_sensitive_operation("displaying private key")?;
    let seed_bytes = read_seed_file()?;
    let seed = RandSeed::seed_from_bytes(&seed_bytes);
    let (signer, key) = generate_setcode_signer(&seed);
    println!("Address:\t{}", signer.address());
    println!("Private Key:\t0x{}", key.encode_hex());
    Ok(())
}

pub fn handle_admin_command(
    command: AdminCommand,
    db: impl DbOps,
) -> Result<(), Box<dyn std::error::Error>> {
    match command {
        AdminCommand::Accounts {
            from_pool,
            num_signers,
        } => handle_accounts(from_pool, num_signers),
        AdminCommand::LatestRunId => {
            let num_runs = db.num_runs()?;
            info!("Latest run ID: {num_runs}");
            println!("{num_runs}");
            Ok(())
        }
        AdminCommand::Seed => handle_seed(),
        AdminCommand::SetCodeSigner => print_setcode_account(),
    }
}
